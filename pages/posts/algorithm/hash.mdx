
# å‰ç«¯ç®—æ³•ç³»åˆ—(å››):å“ˆå¸Œè¡¨ - Mapä¸Setçš„åŸç†ä¸å®æˆ˜

## ä¸€ã€é—®é¢˜å¼•å…¥

ä½œä¸ºå‰ç«¯å¼€å‘å·¥ç¨‹å¸ˆ,ä½ æ¯å¤©éƒ½åœ¨ä½¿ç”¨å“ˆå¸Œè¡¨,åªæ˜¯å¯èƒ½æ²¡æœ‰æ„è¯†åˆ°:

### åœºæ™¯1: æ•°ç»„å»é‡
```javascript
// éœ€æ±‚:å»é™¤æ•°ç»„ä¸­çš„é‡å¤å…ƒç´ 
const arr = [1, 2, 2, 3, 3, 3, 4, 5, 5];

// âŒ åŒé‡å¾ªç¯: O(nÂ²)
const unique1 = arr.filter((item, index) => arr.indexOf(item) === index);

// âœ… ä½¿ç”¨ Set: O(n)
const unique2 = [...new Set(arr)];

// æ€§èƒ½å·®è·:
// 10000 ä¸ªå…ƒç´ : 500ms vs 5ms (å¿« 100 å€!)
```

### åœºæ™¯2: å¿«é€ŸæŸ¥æ‰¾
```javascript
// éœ€æ±‚:åˆ¤æ–­ç”¨æˆ·æ˜¯å¦å·²ç™»å½•
const loggedInUsers = ['user1', 'user2', 'user3', /* ...10000 ä¸ªç”¨æˆ· */];

// âŒ æ•°ç»„æŸ¥æ‰¾: O(n)
const isLoggedIn1 = loggedInUsers.includes('user5000'); // éœ€è¦éå† 5000 æ¬¡

// âœ… ä½¿ç”¨ Set: O(1)
const userSet = new Set(loggedInUsers);
const isLoggedIn2 = userSet.has('user5000'); // ç«‹å³è¿”å›!
```

### åœºæ™¯3: ç»Ÿè®¡è¯é¢‘
```javascript
// éœ€æ±‚:ç»Ÿè®¡æ–‡ç« ä¸­æ¯ä¸ªå•è¯å‡ºç°çš„æ¬¡æ•°
const words = ['hello', 'world', 'hello', 'javascript', 'world'];

// âŒ æ•°ç»„éå†: O(nÂ²)
const count1 = {};
words.forEach(word => {
  count1[word] = (count1[word] || 0) + 1;
});

// âœ… ä½¿ç”¨ Map: O(n)
const count2 = new Map();
words.forEach(word => {
  count2.set(word, (count2.get(word) || 0) + 1);
});
```

### åœºæ™¯4: çŠ¶æ€ç®¡ç†
```javascript
// React ç»„ä»¶çŠ¶æ€ç¼“å­˜
const componentCache = new Map();

function getComponent(id) {
  if (!componentCache.has(id)) {
    componentCache.set(id, createComponent(id));
  }
  return componentCache.get(id);
}

// Vue å“åº”å¼ç³»ç»Ÿçš„ä¾èµ–æ”¶é›†
const targetMap = new WeakMap(); // å­˜å‚¨ä¾èµ–å…³ç³»
```

ä»Šå¤©æˆ‘ä»¬å°†æ·±å…¥å­¦ä¹ **å“ˆå¸Œè¡¨ (Hash Table)**,æŒæ¡ Map å’Œ Set çš„åŸç†ä¸åº”ç”¨ã€‚

---

## äºŒã€ç®—æ³•åŸç†

### ä»€ä¹ˆæ˜¯å“ˆå¸Œè¡¨?

å“ˆå¸Œè¡¨æ˜¯ä¸€ç§é€šè¿‡**å“ˆå¸Œå‡½æ•°**å°†é”®æ˜ å°„åˆ°æ•°ç»„ç´¢å¼•çš„æ•°æ®ç»“æ„:

```
å“ˆå¸Œè¡¨çš„å·¥ä½œåŸç†:

1. å“ˆå¸Œå‡½æ•°: key â†’ hash code â†’ index
    "apple"  â†’ hash("apple") â†’ 3
    "banana" â†’ hash("banana") â†’ 7

2. æ•°ç»„å­˜å‚¨:
    [0] â†’ null
    [1] â†’ null
    [2] â†’ null
    [3] â†’ "apple": 5
    [4] â†’ null
    [5] â†’ null
    [6] â†’ null
    [7] â†’ "banana": 3

3. å¿«é€Ÿè®¿é—®: O(1)
    æŸ¥æ‰¾ "apple" â†’ hash("apple") â†’ 3 â†’ ç›´æ¥è®¿é—®!
```

### å“ˆå¸Œå‡½æ•°

ä¸€ä¸ªå¥½çš„å“ˆå¸Œå‡½æ•°åº”è¯¥:
- **ç¡®å®šæ€§**: ç›¸åŒè¾“å…¥æ€»æ˜¯äº§ç”Ÿç›¸åŒè¾“å‡º
- **å‡åŒ€åˆ†å¸ƒ**: å‡å°‘å†²çª
- **é«˜æ•ˆè®¡ç®—**: å¿«é€Ÿå¾—åˆ°å“ˆå¸Œå€¼

```javascript
/**
  * ç®€å•çš„å­—ç¬¦ä¸²å“ˆå¸Œå‡½æ•°
  */
function simpleHash(str: string, size: number): number {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = (hash * 31 + str.charCodeAt(i)) % size;
  }
  return hash;
}

// ç¤ºä¾‹
simpleHash("apple", 10);  // 3
simpleHash("banana", 10); // 7
```

### å“ˆå¸Œå†²çª

ä¸åŒçš„é”®å¯èƒ½äº§ç”Ÿç›¸åŒçš„å“ˆå¸Œå€¼:

```
å†²çªç¤ºä¾‹:
hash("apple")  = 3
hash("orange") = 3  â† å†²çª!

è§£å†³æ–¹æ³•:

1. é“¾åœ°å€æ³• (Chaining):
    [3] â†’ ["apple": 5] â†’ ["orange": 8]

2. å¼€æ”¾å¯»å€æ³• (Open Addressing):
    [3] â†’ "apple": 5
    [4] â†’ "orange": 8  â† æ”¾åˆ°ä¸‹ä¸€ä¸ªç©ºä½
```

### Map vs Object

<table>
  <thead>
    <tr>
      <th>ç‰¹æ€§</th>
      <th>Map</th>
      <th>Object</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>é”®ç±»å‹</td>
      <td>ä»»æ„ç±»å‹</td>
      <td>å­—ç¬¦ä¸²/Symbol</td>
    </tr>
    <tr>
      <td>é”®é¡ºåº</td>
      <td>æ’å…¥é¡ºåº</td>
      <td>æ— åº(ES2015+æœ‰åº)</td>
    </tr>
    <tr>
      <td>å¤§å°</td>
      <td><code>map.size</code></td>
      <td><code>Object.keys(obj).length</code></td>
    </tr>
    <tr>
      <td>è¿­ä»£</td>
      <td>ç›´æ¥è¿­ä»£</td>
      <td>éœ€è¦ <code>Object.keys()</code></td>
    </tr>
    <tr>
      <td>æ€§èƒ½</td>
      <td>é¢‘ç¹å¢åˆ æ›´å¿«</td>
      <td>å°æ•°æ®é‡æ›´å¿«</td>
    </tr>
    <tr>
      <td>åŸå‹é“¾</td>
      <td>æ— </td>
      <td>æœ‰</td>
    </tr>
  </tbody>
</table>

### Set vs Array

<table>
  <thead>
    <tr>
      <th>ç‰¹æ€§</th>
      <th>Set</th>
      <th>Array</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>é‡å¤å…ƒç´ </td>
      <td>ä¸å…è®¸</td>
      <td>å…è®¸</td>
    </tr>
    <tr>
      <td>æŸ¥æ‰¾</td>
      <td>O(1)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>æ’å…¥</td>
      <td>O(1)</td>
      <td>O(1) æˆ– O(n)</td>
    </tr>
    <tr>
      <td>åˆ é™¤</td>
      <td>O(1)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>é¡ºåº</td>
      <td>æ’å…¥é¡ºåº</td>
      <td>ç´¢å¼•é¡ºåº</td>
    </tr>
  </tbody>
</table>

---

## ä¸‰ã€ä»£ç å®ç°

### 1. ç®€å•å“ˆå¸Œè¡¨å®ç°

```typescript
/**
  * å“ˆå¸Œè¡¨èŠ‚ç‚¹(é“¾åœ°å€æ³•)
  */
class HashNode<K, V> {
  key: K;
  value: V;
  next: HashNode<K, V> | null = null;
  
  constructor(key: K, value: V) {
    this.key = key;
    this.value = value;
  }
}

/**
  * å“ˆå¸Œè¡¨å®ç°
  */
class HashMap<K, V> {
  private buckets: Array<HashNode<K, V> | null>;
  private size: number = 0;
  private capacity: number;
  private loadFactor: number = 0.75;
  
  constructor(capacity: number = 16) {
    this.capacity = capacity;
    this.buckets = new Array(capacity).fill(null);
  }
  
  /**
    * å“ˆå¸Œå‡½æ•°
    */
  private hash(key: K): number {
    const str = String(key);
    let hash = 0;
    
    for (let i = 0; i < str.length; i++) {
      hash = (hash * 31 + str.charCodeAt(i)) % this.capacity;
    }
    
    return Math.abs(hash);
  }
  
  /**
    * è®¾ç½®é”®å€¼å¯¹
    */
  set(key: K, value: V): void {
    const index = this.hash(key);
    let node = this.buckets[index];
    
    // å¦‚æœæ¡¶ä¸ºç©º,ç›´æ¥æ’å…¥
    if (!node) {
      this.buckets[index] = new HashNode(key, value);
      this.size++;
      this.checkResize();
      return;
    }
    
    // éå†é“¾è¡¨
    let prev = null;
    while (node) {
      // å¦‚æœé”®å·²å­˜åœ¨,æ›´æ–°å€¼
      if (node.key === key) {
        node.value = value;
        return;
      }
      prev = node;
      node = node.next;
    }
    
    // æ·»åŠ åˆ°é“¾è¡¨æœ«å°¾
    prev!.next = new HashNode(key, value);
    this.size++;
    this.checkResize();
  }
  
  /**
    * è·å–å€¼
    */
  get(key: K): V | undefined {
    const index = this.hash(key);
    let node = this.buckets[index];
    
    while (node) {
      if (node.key === key) {
        return node.value;
      }
      node = node.next;
    }
    
    return undefined;
  }
  
  /**
    * åˆ é™¤é”®å€¼å¯¹
    */
  delete(key: K): boolean {
    const index = this.hash(key);
    let node = this.buckets[index];
    let prev: HashNode<K, V> | null = null;
    
    while (node) {
      if (node.key === key) {
        if (prev) {
          prev.next = node.next;
        } else {
          this.buckets[index] = node.next;
        }
        this.size--;
        return true;
      }
      prev = node;
      node = node.next;
    }
    
    return false;
  }
  
  /**
    * æ£€æŸ¥æ˜¯å¦å­˜åœ¨
    */
  has(key: K): boolean {
    return this.get(key) !== undefined;
  }
  
  /**
    * æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©å®¹
    */
  private checkResize(): void {
    if (this.size / this.capacity > this.loadFactor) {
      this.resize();
    }
  }
  
  /**
    * æ‰©å®¹
    */
  private resize(): void {
    const oldBuckets = this.buckets;
    this.capacity *= 2;
    this.buckets = new Array(this.capacity).fill(null);
    this.size = 0;
    
    // é‡æ–°æ’å…¥æ‰€æœ‰å…ƒç´ 
    for (const bucket of oldBuckets) {
      let node = bucket;
      while (node) {
        this.set(node.key, node.value);
        node = node.next;
      }
    }
  }
  
  /**
    * è·å–å¤§å°
    */
  getSize(): number {
    return this.size;
  }
  
  /**
    * æ¸…ç©º
    */
  clear(): void {
    this.buckets = new Array(this.capacity).fill(null);
    this.size = 0;
  }
  
  /**
    * è·å–æ‰€æœ‰é”®
    */
  keys(): K[] {
    const keys: K[] = [];
    
    for (const bucket of this.buckets) {
      let node = bucket;
      while (node) {
        keys.push(node.key);
        node = node.next;
      }
    }
    
    return keys;
  }
  
  /**
    * è·å–æ‰€æœ‰å€¼
    */
  values(): V[] {
    const values: V[] = [];
    
    for (const bucket of this.buckets) {
      let node = bucket;
      while (node) {
        values.push(node.value);
        node = node.next;
      }
    }
    
    return values;
  }
  
  /**
    * éå†
    */
  forEach(callback: (value: V, key: K) => void): void {
    for (const bucket of this.buckets) {
      let node = bucket;
      while (node) {
        callback(node.value, node.key);
        node = node.next;
      }
    }
  }
  
  /**
    * æ‰“å°å“ˆå¸Œè¡¨ç»“æ„
    */
  print(): void {
    console.log('\nğŸ“Š å“ˆå¸Œè¡¨ç»“æ„:');
    console.log(`å®¹é‡: ${this.capacity}, å¤§å°: ${this.size}, è´Ÿè½½å› å­: ${(this.size / this.capacity).toFixed(2)}`);
    console.log('â”€'.repeat(50));
    
    this.buckets.forEach((bucket, index) => {
      if (bucket) {
        const chain: string[] = [];
        let node = bucket;
        while (node) {
          chain.push(`${node.key}:${node.value}`);
          node = node.next;
        }
        console.log(`[${index}] â†’ ${chain.join(' â†’ ')}`);
      }
    });
    
    console.log('â”€'.repeat(50));
  }
}

// æµ‹è¯•
const map = new HashMap<string, number>();

map.set('apple', 5);
map.set('banana', 3);
map.set('orange', 8);
map.set('grape', 2);

map.print();

console.log('apple:', map.get('apple'));   // 5
console.log('has banana:', map.has('banana')); // true

map.delete('banana');
console.log('has banana:', map.has('banana')); // false

console.log('keys:', map.keys());
console.log('values:', map.values());
```

---

### 2. Set çš„å®ç°

```typescript
/**
  * Set å®ç°(åŸºäº HashMap)
  */
class HashSet<T> {
  private map: HashMap<T, boolean>;
  
  constructor() {
    this.map = new HashMap<T, boolean>();
  }
  
  /**
    * æ·»åŠ å…ƒç´ 
    */
  add(value: T): void {
    this.map.set(value, true);
  }
  
  /**
    * åˆ é™¤å…ƒç´ 
    */
  delete(value: T): boolean {
    return this.map.delete(value);
  }
  
  /**
    * æ£€æŸ¥æ˜¯å¦å­˜åœ¨
    */
  has(value: T): boolean {
    return this.map.has(value);
  }
  
  /**
    * è·å–å¤§å°
    */
  size(): number {
    return this.map.getSize();
  }
  
  /**
    * æ¸…ç©º
    */
  clear(): void {
    this.map.clear();
  }
  
  /**
    * è½¬æ¢ä¸ºæ•°ç»„
    */
  toArray(): T[] {
    return this.map.keys();
  }
  
  /**
    * éå†
    */
  forEach(callback: (value: T) => void): void {
    this.map.forEach((_, key) => callback(key));
  }
  
  /**
    * å¹¶é›†
    */
  union(other: HashSet<T>): HashSet<T> {
    const result = new HashSet<T>();
    
    this.forEach(value => result.add(value));
    other.forEach(value => result.add(value));
    
    return result;
  }
  
  /**
    * äº¤é›†
    */
  intersection(other: HashSet<T>): HashSet<T> {
    const result = new HashSet<T>();
    
    this.forEach(value => {
      if (other.has(value)) {
        result.add(value);
      }
    });
    
    return result;
  }
  
  /**
    * å·®é›†
    */
  difference(other: HashSet<T>): HashSet<T> {
    const result = new HashSet<T>();
    
    this.forEach(value => {
      if (!other.has(value)) {
        result.add(value);
      }
    });
    
    return result;
  }
  
  /**
    * æ˜¯å¦ä¸ºå­é›†
    */
  isSubsetOf(other: HashSet<T>): boolean {
    let isSubset = true;
    
    this.forEach(value => {
      if (!other.has(value)) {
        isSubset = false;
      }
    });
    
    return isSubset;
  }
}

// æµ‹è¯•
const set1 = new HashSet<number>();
set1.add(1);
set1.add(2);
set1.add(3);

const set2 = new HashSet<number>();
set2.add(2);
set2.add(3);
set2.add(4);

console.log('set1:', set1.toArray()); // [1, 2, 3]
console.log('set2:', set2.toArray()); // [2, 3, 4]

console.log('å¹¶é›†:', set1.union(set2).toArray());        // [1, 2, 3, 4]
console.log('äº¤é›†:', set1.intersection(set2).toArray()); // [2, 3]
console.log('å·®é›†:', set1.difference(set2).toArray());   // [1]
```

---

### 3. ç»å…¸é—®é¢˜:ä¸¤æ•°ä¹‹å’Œ

```typescript
/**
  * ä¸¤æ•°ä¹‹å’Œ - ä½¿ç”¨å“ˆå¸Œè¡¨ O(n)
  */
function twoSum(nums: number[], target: number): number[] {
  const map = new Map<number, number>();
  
  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];
    
    if (map.has(complement)) {
      return [map.get(complement)!, i];
    }
    
    map.set(nums[i], i);
  }
  
  return [];
}

// æµ‹è¯•
console.log(twoSum([2, 7, 11, 15], 9));  // [0, 1]
console.log(twoSum([3, 2, 4], 6));       // [1, 2]

/**
  * å¯è§†åŒ–è¿‡ç¨‹:
  * 
  * nums = [2, 7, 11, 15], target = 9
  * 
  * i=0, num=2:
  *   complement = 9 - 2 = 7
  *   map ä¸­æ²¡æœ‰ 7
  *   map.set(2, 0) â†’ map = {2: 0}
  * 
  * i=1, num=7:
  *   complement = 9 - 7 = 2
  *   map ä¸­æœ‰ 2! ç´¢å¼•ä¸º 0
  *   è¿”å› [0, 1]
  */
```

---

### 4. ç»å…¸é—®é¢˜:å­—æ¯å¼‚ä½è¯åˆ†ç»„

```typescript
/**
  * å­—æ¯å¼‚ä½è¯åˆ†ç»„
  * ä¾‹: ["eat","tea","tan","ate","nat","bat"]
  * è¾“å‡º: [["bat"],["nat","tan"],["ate","eat","tea"]]
  */
function groupAnagrams(strs: string[]): string[][] {
  const map = new Map<string, string[]>();
  
  for (const str of strs) {
    // æ’åºåçš„å­—ç¬¦ä¸²ä½œä¸ºé”®
    const key = str.split('').sort().join('');
    
    if (!map.has(key)) {
      map.set(key, []);
    }
    
    map.get(key)!.push(str);
  }
  
  return Array.from(map.values());
}

// æµ‹è¯•
console.log(groupAnagrams(["eat","tea","tan","ate","nat","bat"]));
// [["eat","tea","ate"], ["tan","nat"], ["bat"]]

/**
  * å¯è§†åŒ–è¿‡ç¨‹:
  * 
  * "eat" â†’ sort â†’ "aet" â†’ map = {"aet": ["eat"]}
  * "tea" â†’ sort â†’ "aet" â†’ map = {"aet": ["eat", "tea"]}
  * "tan" â†’ sort â†’ "ant" â†’ map = {"aet": ["eat", "tea"], "ant": ["tan"]}
  * "ate" â†’ sort â†’ "aet" â†’ map = {"aet": ["eat", "tea", "ate"], "ant": ["tan"]}
  * "nat" â†’ sort â†’ "ant" â†’ map = {"aet": ["eat", "tea", "ate"], "ant": ["tan", "nat"]}
  * "bat" â†’ sort â†’ "abt" â†’ map = {"aet": ["eat", "tea", "ate"], "ant": ["tan", "nat"], "abt": ["bat"]}
  */
```

---

### 5. ç»å…¸é—®é¢˜:æœ€é•¿è¿ç»­åºåˆ—

```typescript
/**
  * æœ€é•¿è¿ç»­åºåˆ—
  * ä¾‹: [100, 4, 200, 1, 3, 2] â†’ 4 (åºåˆ— [1, 2, 3, 4])
  */
function longestConsecutive(nums: number[]): number {
  const set = new Set(nums);
  let maxLength = 0;
  
  for (const num of set) {
    // åªä»åºåˆ—çš„èµ·ç‚¹å¼€å§‹è®¡ç®—
    if (!set.has(num - 1)) {
      let currentNum = num;
      let currentLength = 1;
      
      // è®¡ç®—è¿ç»­åºåˆ—é•¿åº¦
      while (set.has(currentNum + 1)) {
        currentNum++;
        currentLength++;
      }
      
      maxLength = Math.max(maxLength, currentLength);
    }
  }
  
  return maxLength;
}

// æµ‹è¯•
console.log(longestConsecutive([100, 4, 200, 1, 3, 2])); // 4
console.log(longestConsecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1])); // 9

/**
  * å¯è§†åŒ–è¿‡ç¨‹:
  * 
  * nums = [100, 4, 200, 1, 3, 2]
  * set = {100, 4, 200, 1, 3, 2}
  * 
  * num = 100:
  *   æ²¡æœ‰ 99,æ˜¯èµ·ç‚¹
  *   100 â†’ æ²¡æœ‰ 101
  *   é•¿åº¦ = 1
  * 
  * num = 4:
  *   æœ‰ 3,ä¸æ˜¯èµ·ç‚¹,è·³è¿‡
  * 
  * num = 200:
  *   æ²¡æœ‰ 199,æ˜¯èµ·ç‚¹
  *   200 â†’ æ²¡æœ‰ 201
  *   é•¿åº¦ = 1
  * 
  * num = 1:
  *   æ²¡æœ‰ 0,æ˜¯èµ·ç‚¹
  *   1 â†’ 2 â†’ 3 â†’ 4 â†’ æ²¡æœ‰ 5
  *   é•¿åº¦ = 4 âœ“
  * 
  * æœ€é•¿è¿ç»­åºåˆ—: [1, 2, 3, 4]
  */
```

---

## å››ã€å¤æ‚åº¦åˆ†æ

### æ—¶é—´å¤æ‚åº¦

| æ“ä½œ | å“ˆå¸Œè¡¨(å¹³å‡) | å“ˆå¸Œè¡¨(æœ€å) | æ•°ç»„ | é“¾è¡¨ |
|------|------------|------------|------|------|
| æŸ¥æ‰¾ | O(1) | O(n) | O(n) | O(n) |
| æ’å…¥ | O(1) | O(n) | O(1) | O(1) |
| åˆ é™¤ | O(1) | O(n) | O(n) | O(n) |

### ç©ºé—´å¤æ‚åº¦

- **å“ˆå¸Œè¡¨**: O(n) - å­˜å‚¨ n ä¸ªå…ƒç´ 
- **è´Ÿè½½å› å­**: é€šå¸¸è®¾ç½®ä¸º 0.75
  - å¤ªå°:æµªè´¹ç©ºé—´
  - å¤ªå¤§:å†²çªå¢å¤š,æ€§èƒ½ä¸‹é™

### å“ˆå¸Œè¡¨ vs å…¶ä»–æ•°æ®ç»“æ„

<table>
  <thead>
    <tr>
      <th>åœºæ™¯</th>
      <th>æœ€ä½³é€‰æ‹©</th>
      <th>åŸå› </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>å¿«é€ŸæŸ¥æ‰¾</td>
      <td>å“ˆå¸Œè¡¨</td>
      <td>O(1) æŸ¥æ‰¾</td>
    </tr>
    <tr>
      <td>æœ‰åºéå†</td>
      <td>BST/æ•°ç»„</td>
      <td>å“ˆå¸Œè¡¨æ— åº</td>
    </tr>
    <tr>
      <td>èŒƒå›´æŸ¥è¯¢</td>
      <td>BST</td>
      <td>æ”¯æŒèŒƒå›´æŸ¥è¯¢</td>
    </tr>
    <tr>
      <td>å»é‡</td>
      <td>Set</td>
      <td>è‡ªåŠ¨å»é‡</td>
    </tr>
    <tr>
      <td>è®¡æ•°</td>
      <td>Map</td>
      <td>é”®å€¼å¯¹å­˜å‚¨</td>
    </tr>
    <tr>
      <td>å†…å­˜å—é™</td>
      <td>æ•°ç»„</td>
      <td>æ— é¢å¤–å¼€é”€</td>
    </tr>
  </tbody>
</table>

---

## äº”ã€å®æˆ˜åº”ç”¨

### æ¡ˆä¾‹1: LRU ç¼“å­˜(Map + åŒå‘é“¾è¡¨)

```typescript
/**
  * LRU ç¼“å­˜
  * ä½¿ç”¨ Map ä¿æŒæ’å…¥é¡ºåº
  */
class LRUCache<K, V> {
  private cache: Map<K, V>;
  private capacity: number;
  
  constructor(capacity: number) {
    this.capacity = capacity;
    this.cache = new Map();
  }
  
  /**
    * è·å–å€¼
    */
  get(key: K): V | undefined {
    if (!this.cache.has(key)) {
      return undefined;
    }
    
    // æ›´æ–°è®¿é—®é¡ºåº(åˆ é™¤åé‡æ–°æ’å…¥)
    const value = this.cache.get(key)!;
    this.cache.delete(key);
    this.cache.set(key, value);
    
    return value;
  }
  
  /**
    * è®¾ç½®å€¼
    */
  put(key: K, value: V): void {
    // å¦‚æœé”®å·²å­˜åœ¨,å…ˆåˆ é™¤
    if (this.cache.has(key)) {
      this.cache.delete(key);
    }
    
    // æ’å…¥æ–°å€¼
    this.cache.set(key, value);
    
    // å¦‚æœè¶…å‡ºå®¹é‡,åˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„(Map çš„ç¬¬ä¸€ä¸ªå…ƒç´ )
    if (this.cache.size > this.capacity) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
      console.log(`ğŸ—‘ï¸  æ·˜æ±°: ${firstKey}`);
    }
  }
  
  /**
    * è·å–ç¼“å­˜çŠ¶æ€
    */
  getStatus(): { size: number; keys: K[] } {
    return {
      size: this.cache.size,
      keys: Array.from(this.cache.keys())
    };
  }
  
  /**
    * æ‰“å°ç¼“å­˜
    */
  print(): void {
    console.log('\nğŸ’¾ LRU ç¼“å­˜:');
    console.log(`å®¹é‡: ${this.capacity}, å½“å‰: ${this.cache.size}`);
    console.log('é¡ºåº(æœ€è¿‘ â†’ æœ€ä¹…):');
    
    const entries = Array.from(this.cache.entries()).reverse();
    entries.forEach(([key, value], index) => {
      console.log(`  ${index + 1}. ${key}: ${value}`);
    });
  }
}

// æµ‹è¯•
const lru = new LRUCache<string, number>(3);

lru.put('a', 1);
lru.put('b', 2);
lru.put('c', 3);
lru.print();
// é¡ºåº: c, b, a

lru.get('a'); // è®¿é—® a
lru.print();
// é¡ºåº: a, c, b (a ç§»åˆ°æœ€å‰)

lru.put('d', 4); // æ·˜æ±° b
lru.print();
// é¡ºåº: d, a, c
```

---

### æ¡ˆä¾‹2: è¯·æ±‚å»é‡ä¸é˜²æŠ–

```typescript
/**
  * è¯·æ±‚å»é‡ç®¡ç†å™¨
  * é˜²æ­¢ç›¸åŒè¯·æ±‚é‡å¤å‘é€
  */
class RequestDeduplicator {
  private pendingRequests: Map<string, Promise<any>>;
  private cache: Map<string, { data: any; timestamp: number }>;
  private cacheTTL: number;
  
  constructor(cacheTTL: number = 60000) { // é»˜è®¤ç¼“å­˜ 60 ç§’
    this.pendingRequests = new Map();
    this.cache = new Map();
    this.cacheTTL = cacheTTL;
  }
  
  /**
    * ç”Ÿæˆè¯·æ±‚é”®
    */
  private generateKey(url: string, options?: RequestInit): string {
    return `${url}:${JSON.stringify(options || {})}`;
  }
  
  /**
    * å‘èµ·è¯·æ±‚(è‡ªåŠ¨å»é‡)
    */
  async fetch(url: string, options?: RequestInit): Promise<any> {
    const key = this.generateKey(url, options);
    
    // 1. æ£€æŸ¥ç¼“å­˜
    const cached = this.cache.get(key);
    if (cached && Date.now() - cached.timestamp < this.cacheTTL) {
      console.log(`âœ… å‘½ä¸­ç¼“å­˜: ${url}`);
      return cached.data;
    }
    
    // 2. æ£€æŸ¥æ˜¯å¦æœ‰ç›¸åŒçš„è¯·æ±‚æ­£åœ¨è¿›è¡Œ
    if (this.pendingRequests.has(key)) {
      console.log(`â³ ç­‰å¾…è¿›è¡Œä¸­çš„è¯·æ±‚: ${url}`);
      return this.pendingRequests.get(key);
    }
    
    // 3. å‘èµ·æ–°è¯·æ±‚
    console.log(`ğŸŒ å‘èµ·æ–°è¯·æ±‚: ${url}`);
    const promise = fetch(url, options)
      .then(response => response.json())
      .then(data => {
        // ç¼“å­˜ç»“æœ
        this.cache.set(key, {
          data,
          timestamp: Date.now()
        });
        
        // ç§»é™¤å¾…å¤„ç†è¯·æ±‚
        this.pendingRequests.delete(key);
        
        return data;
      })
      .catch(error => {
        // ç§»é™¤å¾…å¤„ç†è¯·æ±‚
        this.pendingRequests.delete(key);
        throw error;
      });
    
    this.pendingRequests.set(key, promise);
    return promise;
  }
  
  /**
    * æ¸…é™¤ç¼“å­˜
    */
  clearCache(): void {
    this.cache.clear();
    console.log('ğŸ—‘ï¸  ç¼“å­˜å·²æ¸…é™¤');
  }
  
  /**
    * æ¸…é™¤è¿‡æœŸç¼“å­˜
    */
  cleanExpiredCache(): void {
    const now = Date.now();
    let cleaned = 0;
    
    for (const [key, value] of this.cache.entries()) {
      if (now - value.timestamp >= this.cacheTTL) {
        this.cache.delete(key);
        cleaned++;
      }
    }
    
    if (cleaned > 0) {
      console.log(`ğŸ§¹ æ¸…ç†äº† ${cleaned} ä¸ªè¿‡æœŸç¼“å­˜`);
    }
  }
  
  /**
    * è·å–ç»Ÿè®¡ä¿¡æ¯
    */
  getStats(): {
    cacheSize: number;
    pendingCount: number;
    cacheKeys: string[];
  } {
    return {
      cacheSize: this.cache.size,
      pendingCount: this.pendingRequests.size,
      cacheKeys: Array.from(this.cache.keys())
    };
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const deduplicator = new RequestDeduplicator(5000); // 5ç§’ç¼“å­˜

// æ¨¡æ‹Ÿå¤šä¸ªç»„ä»¶åŒæ—¶è¯·æ±‚ç›¸åŒæ•°æ®
async function simulateRequests() {
  const url = 'https://api.example.com/users';
  
  // åŒæ—¶å‘èµ· 3 ä¸ªç›¸åŒè¯·æ±‚
  const promises = [
    deduplicator.fetch(url),
    deduplicator.fetch(url),
    deduplicator.fetch(url)
  ];
  
  // åªä¼šå‘èµ· 1 ä¸ªå®é™…è¯·æ±‚,å…¶ä»– 2 ä¸ªä¼šç­‰å¾…
  const results = await Promise.all(promises);
  
  console.log('æ‰€æœ‰è¯·æ±‚å®Œæˆ,ç»“æœç›¸åŒ:', 
    results[0] === results[1] && results[1] === results[2]
  );
}

// å®šæœŸæ¸…ç†è¿‡æœŸç¼“å­˜
setInterval(() => {
  deduplicator.cleanExpiredCache();
}, 60000);
```

---

### æ¡ˆä¾‹3: çŠ¶æ€ç®¡ç†ä¼˜åŒ–

```typescript
/**
  * é«˜æ€§èƒ½çŠ¶æ€ç®¡ç†å™¨
  * ä½¿ç”¨ Map å’Œ Set ä¼˜åŒ–çŠ¶æ€æŸ¥æ‰¾å’Œè®¢é˜…
  */
class StateManager<T = any> {
  private state: Map<string, T>;
  private subscribers: Map<string, Set<(value: T) => void>>;
  private computedCache: Map<string, { value: any; deps: string[] }>;
  
  constructor() {
    this.state = new Map();
    this.subscribers = new Map();
    this.computedCache = new Map();
  }
  
  /**
    * è®¾ç½®çŠ¶æ€
    */
  setState(key: string, value: T): void {
    const oldValue = this.state.get(key);
    
    // å€¼æœªæ”¹å˜,ä¸è§¦å‘æ›´æ–°
    if (oldValue === value) {
      return;
    }
    
    this.state.set(key, value);
    
    // æ¸…é™¤ç›¸å…³çš„è®¡ç®—å±æ€§ç¼“å­˜
    this.invalidateComputedCache(key);
    
    // é€šçŸ¥è®¢é˜…è€…
    this.notify(key, value);
    
    console.log(`ğŸ“ çŠ¶æ€æ›´æ–°: ${key} = ${value}`);
  }
  
  /**
    * è·å–çŠ¶æ€
    */
  getState(key: string): T | undefined {
    return this.state.get(key);
  }
  
  /**
    * è®¢é˜…çŠ¶æ€å˜åŒ–
    */
  subscribe(key: string, callback: (value: T) => void): () => void {
    if (!this.subscribers.has(key)) {
      this.subscribers.set(key, new Set());
    }
    
    this.subscribers.get(key)!.add(callback);
    
    // è¿”å›å–æ¶ˆè®¢é˜…å‡½æ•°
    return () => {
      this.subscribers.get(key)?.delete(callback);
    };
  }
  
  /**
    * é€šçŸ¥è®¢é˜…è€…
    */
  private notify(key: string, value: T): void {
    const callbacks = this.subscribers.get(key);
    
    if (callbacks) {
      callbacks.forEach(callback => callback(value));
    }
  }
  
  /**
    * å®šä¹‰è®¡ç®—å±æ€§
    */
  defineComputed(
    key: string,
    deps: string[],
    compute: (...values: any[]) => any
  ): void {
    this.computedCache.set(key, {
      value: undefined,
      deps
    });
    
    // è®¢é˜…ä¾èµ–å˜åŒ–
    deps.forEach(dep => {
      this.subscribe(dep, () => {
        this.invalidateComputedCache(key);
      });
    });
  }
  
  /**
    * è·å–è®¡ç®—å±æ€§
    */
  getComputed(key: string, compute: (...values: any[]) => any): any {
    const cached = this.computedCache.get(key);
    
    if (!cached) {
      return undefined;
    }
    
    // å¦‚æœç¼“å­˜æœ‰æ•ˆ,ç›´æ¥è¿”å›
    if (cached.value !== undefined) {
      console.log(`âœ… å‘½ä¸­è®¡ç®—å±æ€§ç¼“å­˜: ${key}`);
      return cached.value;
    }
    
    // é‡æ–°è®¡ç®—
    const depValues = cached.deps.map(dep => this.state.get(dep));
    cached.value = compute(...depValues);
    
    console.log(`ğŸ”„ é‡æ–°è®¡ç®—: ${key} = ${cached.value}`);
    return cached.value;
  }
  
  /**
    * æ¸…é™¤è®¡ç®—å±æ€§ç¼“å­˜
    */
  private invalidateComputedCache(changedKey: string): void {
    for (const [key, cached] of this.computedCache.entries()) {
      if (cached.deps.includes(changedKey)) {
        cached.value = undefined;
        console.log(`ğŸ—‘ï¸  æ¸…é™¤ç¼“å­˜: ${key}`);
      }
    }
  }
  
  /**
    * æ‰¹é‡æ›´æ–°(å‡å°‘é€šçŸ¥æ¬¡æ•°)
    */
  batchUpdate(updates: Record<string, T>): void {
    const changedKeys = new Set<string>();
    
    // æ”¶é›†æ‰€æœ‰å˜åŒ–
    for (const [key, value] of Object.entries(updates)) {
      const oldValue = this.state.get(key);
      if (oldValue !== value) {
        this.state.set(key, value);
        changedKeys.add(key);
      }
    }
    
    // æ‰¹é‡é€šçŸ¥
    changedKeys.forEach(key => {
      this.notify(key, this.state.get(key)!);
    });
    
    console.log(`ğŸ“¦ æ‰¹é‡æ›´æ–°: ${changedKeys.size} ä¸ªçŠ¶æ€`);
  }
  
  /**
    * è·å–ç»Ÿè®¡ä¿¡æ¯
    */
  getStats(): {
    stateCount: number;
    subscriberCount: number;
    computedCount: number;
  } {
    let subscriberCount = 0;
    this.subscribers.forEach(set => {
      subscriberCount += set.size;
    });
    
    return {
      stateCount: this.state.size,
      subscriberCount,
      computedCount: this.computedCache.size
    };
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const store = new StateManager<number>();

// è®¾ç½®çŠ¶æ€
store.setState('count', 0);
store.setState('multiplier', 2);

// è®¢é˜…çŠ¶æ€
const unsubscribe = store.subscribe('count', (value) => {
  console.log(`ğŸ‘€ count å˜åŒ–: ${value}`);
});

// å®šä¹‰è®¡ç®—å±æ€§
store.defineComputed('doubleCount', ['count', 'multiplier'], 
  (count, multiplier) => count * multiplier
);

// æ›´æ–°çŠ¶æ€
store.setState('count', 5);
// ğŸ“ çŠ¶æ€æ›´æ–°: count = 5
// ğŸ‘€ count å˜åŒ–: 5
// ğŸ—‘ï¸  æ¸…é™¤ç¼“å­˜: doubleCount

// è·å–è®¡ç®—å±æ€§
const double = store.getComputed('doubleCount', 
  (count, multiplier) => count * multiplier
);
console.log('doubleCount:', double); // 10

// å†æ¬¡è·å–(å‘½ä¸­ç¼“å­˜)
const double2 = store.getComputed('doubleCount', 
  (count, multiplier) => count * multiplier
);
// âœ… å‘½ä¸­è®¡ç®—å±æ€§ç¼“å­˜: doubleCount

// æ‰¹é‡æ›´æ–°
store.batchUpdate({
  count: 10,
  multiplier: 3
});
// ğŸ“¦ æ‰¹é‡æ›´æ–°: 2 ä¸ªçŠ¶æ€

console.log('ç»Ÿè®¡:', store.getStats());
```

---

### æ¡ˆä¾‹4: è¯é¢‘ç»Ÿè®¡ä¸çƒ­è¯åˆ†æ

```typescript
/**
  * è¯é¢‘ç»Ÿè®¡å™¨
  * ç”¨äºæ–‡æœ¬åˆ†æã€çƒ­è¯æå–
  */
class WordFrequencyAnalyzer {
  private wordCount: Map<string, number>;
  private stopWords: Set<string>;
  
  constructor() {
    this.wordCount = new Map();
    
    // åœç”¨è¯(å¸¸è§ä½†æ— æ„ä¹‰çš„è¯)
    this.stopWords = new Set([
      'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at',
      'to', 'for', 'of', 'with', 'by', 'from', 'is', 'was',
      'are', 'were', 'be', 'been', 'being', 'have', 'has', 'had'
    ]);
  }
  
  /**
    * æ·»åŠ åœç”¨è¯
    */
  addStopWords(words: string[]): void {
    words.forEach(word => this.stopWords.add(word.toLowerCase()));
  }
  
  /**
    * åˆ†ææ–‡æœ¬
    */
  analyze(text: string): void {
    // åˆ†è¯(ç®€å•å®ç°,å®é™…å¯ç”¨æ›´å¤æ‚çš„åˆ†è¯ç®—æ³•)
    const words = text
      .toLowerCase()
      .replace(/[^\w\s]/g, ' ') // ç§»é™¤æ ‡ç‚¹
      .split(/\s+/)
      .filter(word => word.length > 0 && !this.stopWords.has(word));
    
    // ç»Ÿè®¡è¯é¢‘
    words.forEach(word => {
      this.wordCount.set(word, (this.wordCount.get(word) || 0) + 1);
    });
  }
  
  /**
    * è·å–è¯é¢‘
    */
  getFrequency(word: string): number {
    return this.wordCount.get(word.toLowerCase()) || 0;
  }
  
  /**
    * è·å–å‰ K ä¸ªé«˜é¢‘è¯
    */
  getTopK(k: number): Array<{ word: string; count: number }> {
    const entries = Array.from(this.wordCount.entries());
    
    // æŒ‰é¢‘ç‡é™åºæ’åº
    entries.sort((a, b) => b[1] - a[1]);
    
    return entries.slice(0, k).map(([word, count]) => ({ word, count }));
  }
  
  /**
    * è·å–æ‰€æœ‰è¯é¢‘(æŒ‰é¢‘ç‡æ’åº)
    */
  getAllWords(): Array<{ word: string; count: number }> {
    const entries = Array.from(this.wordCount.entries());
    entries.sort((a, b) => b[1] - a[1]);
    return entries.map(([word, count]) => ({ word, count }));
  }
  
  /**
    * æŸ¥æ‰¾åŒ…å«æŒ‡å®šå‰ç¼€çš„è¯
    */
  findWordsWithPrefix(prefix: string): Array<{ word: string; count: number }> {
    const result: Array<{ word: string; count: number }> = [];
    prefix = prefix.toLowerCase();
    
    for (const [word, count] of this.wordCount.entries()) {
      if (word.startsWith(prefix)) {
        result.push({ word, count });
      }
    }
    
    result.sort((a, b) => b.count - a.count);
    return result;
  }
  
  /**
    * ç”Ÿæˆè¯äº‘æ•°æ®
    */
  generateWordCloud(maxWords: number = 50): Array<{
    text: string;
    size: number;
  }> {
    const topWords = this.getTopK(maxWords);
    const maxCount = topWords[0]?.count || 1;
    
    return topWords.map(({ word, count }) => ({
      text: word,
      size: Math.floor((count / maxCount) * 100) + 20 // 20-120 çš„å­—ä½“å¤§å°
    }));
  }
  
  /**
    * ç»Ÿè®¡ä¿¡æ¯
    */
  getStats(): {
    totalWords: number;
    uniqueWords: number;
    avgFrequency: number;
  } {
    const totalWords = Array.from(this.wordCount.values())
      .reduce((sum, count) => sum + count, 0);
    
    return {
      totalWords,
      uniqueWords: this.wordCount.size,
      avgFrequency: totalWords / this.wordCount.size
    };
  }
  
  /**
    * æ¸…ç©ºç»Ÿè®¡
    */
  clear(): void {
    this.wordCount.clear();
  }
  
  /**
    * æ‰“å°è¯é¢‘ç»Ÿè®¡
    */
  print(limit: number = 20): void {
    const topWords = this.getTopK(limit);
    const stats = this.getStats();
    
    console.log('\nğŸ“Š è¯é¢‘ç»Ÿè®¡');
    console.log('â”€'.repeat(50));
    console.log(`æ€»è¯æ•°: ${stats.totalWords}`);
    console.log(`ä¸é‡å¤è¯æ•°: ${stats.uniqueWords}`);
    console.log(`å¹³å‡é¢‘ç‡: ${stats.avgFrequency.toFixed(2)}`);
    console.log('\nğŸ”¥ é«˜é¢‘è¯ Top', limit);
    console.log('â”€'.repeat(50));
    
    topWords.forEach(({ word, count }, index) => {
      const bar = 'â–ˆ'.repeat(Math.floor(count / topWords[0].count * 20));
      console.log(`${(index + 1).toString().padStart(2)}. ${word.padEnd(15)} ${bar} ${count}`);
    });
    
    console.log('â”€'.repeat(50));
  }
}

// æµ‹è¯•
const analyzer = new WordFrequencyAnalyzer();

const text = `
  JavaScript is a programming language that is one of the core technologies
  of the World Wide Web. JavaScript enables interactive web pages and is an
  essential part of web applications. The vast majority of websites use
  JavaScript, and all major web browsers have a dedicated JavaScript engine
  to execute it. JavaScript is a high-level, often just-in-time compiled
  language that conforms to the ECMAScript standard.
`;

analyzer.analyze(text);
analyzer.print(10);

// æŸ¥æ‰¾ä»¥ "java" å¼€å¤´çš„è¯
console.log('\nä»¥ "java" å¼€å¤´çš„è¯:');
const javaWords = analyzer.findWordsWithPrefix('java');
javaWords.forEach(({ word, count }) => {
  console.log(`  ${word}: ${count}`);
});

// ç”Ÿæˆè¯äº‘æ•°æ®
const wordCloudData = analyzer.generateWordCloud(10);
console.log('\nâ˜ï¸  è¯äº‘æ•°æ®:');
console.log(wordCloudData);
```

---

### æ¡ˆä¾‹5: æ•°æ®å»é‡ä¸åˆå¹¶

```typescript
/**
  * æ•°æ®å»é‡åˆå¹¶å™¨
  * ç”¨äºå¤„ç†é‡å¤æ•°æ®ã€åˆå¹¶æ•°æ®æº
  */
class DataDeduplicator<T> {
  private seen: Set<string>;
  private keyExtractor: (item: T) => string;
  
  constructor(keyExtractor: (item: T) => string) {
    this.seen = new Set();
    this.keyExtractor = keyExtractor;
  }
  
  /**
    * å»é‡æ•°ç»„
    */
  deduplicate(items: T[]): T[] {
    this.seen.clear();
    const result: T[] = [];
    
    for (const item of items) {
      const key = this.keyExtractor(item);
      
      if (!this.seen.has(key)) {
        this.seen.add(key);
        result.push(item);
      }
    }
    
    return result;
  }
  
  /**
    * åˆå¹¶å¤šä¸ªæ•°æ®æº(å»é‡)
    */
  merge(...sources: T[][]): T[] {
    this.seen.clear();
    const result: T[] = [];
    
    for (const source of sources) {
      for (const item of source) {
        const key = this.keyExtractor(item);
        
        if (!this.seen.has(key)) {
          this.seen.add(key);
          result.push(item);
        }
      }
    }
    
    return result;
  }
  
  /**
    * æ‰¾å‡ºé‡å¤é¡¹
    */
  findDuplicates(items: T[]): T[] {
    const seen = new Set<string>();
    const duplicates = new Set<string>();
    const result: T[] = [];
    
    for (const item of items) {
      const key = this.keyExtractor(item);
      
      if (seen.has(key)) {
        if (!duplicates.has(key)) {
          duplicates.add(key);
          result.push(item);
        }
      } else {
        seen.add(key);
      }
    }
    
    return result;
  }
  
  /**
    * ç»Ÿè®¡é‡å¤æ¬¡æ•°
    */
  countDuplicates(items: T[]): Map<string, number> {
    const counts = new Map<string, number>();
    
    for (const item of items) {
      const key = this.keyExtractor(item);
      counts.set(key, (counts.get(key) || 0) + 1);
    }
    
    return counts;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
interface User {
  id: number;
  name: string;
  email: string;
}

const deduplicator = new DataDeduplicator<User>(user => user.email);

const users1 = [
  { id: 1, name: 'Alice', email: 'alice@example.com' },
  { id: 2, name: 'Bob', email: 'bob@example.com' },
  { id: 3, name: 'Alice', email: 'alice@example.com' } // é‡å¤
];

const users2 = [
  { id: 4, name: 'Charlie', email: 'charlie@example.com' },
  { id: 5, name: 'Bob', email: 'bob@example.com' } // é‡å¤
];

// å»é‡
const unique = deduplicator.deduplicate(users1);
console.log('å»é‡å:', unique.length); // 2

// åˆå¹¶å¤šä¸ªæ•°æ®æº
const merged = deduplicator.merge(users1, users2);
console.log('åˆå¹¶å:', merged.length); // 3

// æ‰¾å‡ºé‡å¤é¡¹
const duplicates = deduplicator.findDuplicates(users1);
console.log('é‡å¤é¡¹:', duplicates);

// ç»Ÿè®¡é‡å¤æ¬¡æ•°
const counts = deduplicator.countDuplicates(users1);
console.log('é‡å¤ç»Ÿè®¡:', counts);
```

---

## å…­ã€æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### 1. é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„

```typescript
/**
  * æ€§èƒ½å¯¹æ¯”æµ‹è¯•
  */
function performanceTest() {
  const size = 100000;
  const data = Array.from({ length: size }, (_, i) => i);
  
  // æµ‹è¯• 1: æ•°ç»„æŸ¥æ‰¾ vs Set æŸ¥æ‰¾
  console.time('æ•°ç»„æŸ¥æ‰¾');
  for (let i = 0; i < 1000; i++) {
    data.includes(Math.floor(Math.random() * size));
  }
  console.timeEnd('æ•°ç»„æŸ¥æ‰¾');
  // çº¦ 500ms
  
  const dataSet = new Set(data);
  console.time('Set æŸ¥æ‰¾');
  for (let i = 0; i < 1000; i++) {
    dataSet.has(Math.floor(Math.random() * size));
  }
  console.timeEnd('Set æŸ¥æ‰¾');
  // çº¦ 0.5ms (å¿« 1000 å€!)
  
  // æµ‹è¯• 2: Object vs Map
  const obj: Record<string, number> = {};
  const map = new Map<string, number>();
  
  console.time('Object æ’å…¥');
  for (let i = 0; i < size; i++) {
    obj[`key${i}`] = i;
  }
  console.timeEnd('Object æ’å…¥');
  
  console.time('Map æ’å…¥');
  for (let i = 0; i < size; i++) {
    map.set(`key${i}`, i);
  }
  console.timeEnd('Map æ’å…¥');
  // Map é€šå¸¸æ›´å¿«
}
```

### 2. é¿å…ä¸å¿…è¦çš„å“ˆå¸Œè®¡ç®—

```typescript
// âŒ æ¯æ¬¡éƒ½è®¡ç®—å“ˆå¸Œ
function badExample(items: string[]) {
  const set = new Set<string>();
  
  for (const item of items) {
    if (!set.has(item.toLowerCase())) { // è®¡ç®—å“ˆå¸Œ
      set.add(item.toLowerCase());      // å†æ¬¡è®¡ç®—å“ˆå¸Œ
    }
  }
}

// âœ… ç¼“å­˜å“ˆå¸Œç»“æœ
function goodExample(items: string[]) {
  const set = new Set<string>();
  
  for (const item of items) {
    const key = item.toLowerCase(); // åªè®¡ç®—ä¸€æ¬¡
    if (!set.has(key)) {
      set.add(key);
    }
  }
}
```

### 3. ä½¿ç”¨ WeakMap/WeakSet é¿å…å†…å­˜æ³„æ¼

```typescript
/**
  * ä½¿ç”¨ WeakMap ç¼“å­˜ DOM å…ƒç´ ç›¸å…³æ•°æ®
  */
class DOMCache {
  private cache = new WeakMap<HTMLElement, any>();
  
  set(element: HTMLElement, data: any): void {
    this.cache.set(element, data);
  }
  
  get(element: HTMLElement): any {
    return this.cache.get(element);
  }
}

// å½“ DOM å…ƒç´ è¢«ç§»é™¤æ—¶,ç¼“å­˜ä¼šè‡ªåŠ¨æ¸…ç†
// ä¸ä¼šé€ æˆå†…å­˜æ³„æ¼!
```

---

## ä¸ƒã€ç»ƒä¹ é¢˜

### é¢˜ç›®1: æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯ (LeetCode 242)

**éš¾åº¦**: ç®€å•

```typescript
/**
  * åˆ¤æ–­ä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ä¸ºå­—æ¯å¼‚ä½è¯
  */
function isAnagram(s: string, t: string): boolean {
  // åœ¨è¿™é‡Œå®ç°ä½ çš„ä»£ç 
}

// æµ‹è¯•ç”¨ä¾‹
console.log(isAnagram("anagram", "nagaram")); // true
console.log(isAnagram("rat", "car"));         // false
```

**æç¤º**: ä½¿ç”¨ Map ç»Ÿè®¡å­—ç¬¦é¢‘ç‡

<details>
<summary>ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

```typescript
function isAnagram(s: string, t: string): boolean {
  if (s.length !== t.length) return false;
  
  const count = new Map<string, number>();
  
  // ç»Ÿè®¡ s ä¸­çš„å­—ç¬¦
  for (const char of s) {
    count.set(char, (count.get(char) || 0) + 1);
  }
  
  // å‡å» t ä¸­çš„å­—ç¬¦
  for (const char of t) {
    const freq = count.get(char);
    if (!freq) return false;
    
    if (freq === 1) {
      count.delete(char);
    } else {
      count.set(char, freq - 1);
    }
  }
  
  return count.size === 0;
}
```

**æ—¶é—´å¤æ‚åº¦**: O(n)  
**ç©ºé—´å¤æ‚åº¦**: O(1) - æœ€å¤š 26 ä¸ªå­—æ¯
</details>

---

### é¢˜ç›®2: ç¬¬ä¸€ä¸ªåªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦ (LeetCode 387)

**éš¾åº¦**: ç®€å•

```typescript
/**
  * æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­ç¬¬ä¸€ä¸ªä¸é‡å¤çš„å­—ç¬¦
  */
function firstUniqChar(s: string): number {
  // åœ¨è¿™é‡Œå®ç°ä½ çš„ä»£ç 
}

// æµ‹è¯•ç”¨ä¾‹
console.log(firstUniqChar("leetcode"));     // 0 ('l')
console.log(firstUniqChar("loveleetcode")); // 2 ('v')
console.log(firstUniqChar("aabb"));         // -1
```

---

### é¢˜ç›®3: å‰ K ä¸ªé«˜é¢‘å…ƒç´  (LeetCode 347)

**éš¾åº¦**: ä¸­ç­‰

```typescript
/**
  * è¿”å›æ•°ç»„ä¸­å‡ºç°é¢‘ç‡å‰ k é«˜çš„å…ƒç´ 
  */
function topKFrequent(nums: number[], k: number): number[] {
  // åœ¨è¿™é‡Œå®ç°ä½ çš„ä»£ç 
}

// æµ‹è¯•ç”¨ä¾‹
console.log(topKFrequent([1,1,1,2,2,3], 2)); // [1, 2]
console.log(topKFrequent([1], 1));            // [1]
```

**æç¤º**: Map ç»Ÿè®¡é¢‘ç‡ + æ’åº

---

## å…«ã€æ€»ç»“ä¸æ‰©å±•

### æ ¸å¿ƒè¦ç‚¹

1. **å“ˆå¸Œè¡¨åŸç†**:
    - å“ˆå¸Œå‡½æ•°: key â†’ index
    - å†²çªè§£å†³: é“¾åœ°å€æ³•ã€å¼€æ”¾å¯»å€
    - è´Ÿè½½å› å­: æ§åˆ¶æ‰©å®¹æ—¶æœº

2. **Map vs Object**:
    - Map: ä»»æ„ç±»å‹é”®ã€æœ‰åºã€æ€§èƒ½å¥½
    - Object: å­—ç¬¦ä¸²é”®ã€åŸå‹é“¾ã€å°æ•°æ®å¿«

3. **Set vs Array**:
    - Set: è‡ªåŠ¨å»é‡ã€O(1) æŸ¥æ‰¾
    - Array: å…è®¸é‡å¤ã€O(n) æŸ¥æ‰¾

4. **å®æˆ˜åº”ç”¨**:
    - LRU ç¼“å­˜
    - è¯·æ±‚å»é‡
    - çŠ¶æ€ç®¡ç†
    - è¯é¢‘ç»Ÿè®¡
    - æ•°æ®å»é‡

### ä½¿ç”¨åœºæ™¯é€‰æ‹©

<table>
  <thead>
    <tr>
      <th>åœºæ™¯</th>
      <th>æ¨èæ•°æ®ç»“æ„</th>
      <th>åŸå› </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>å¿«é€ŸæŸ¥æ‰¾</td>
      <td>Map/Set</td>
      <td>O(1) æŸ¥æ‰¾</td>
    </tr>
    <tr>
      <td>å»é‡</td>
      <td>Set</td>
      <td>è‡ªåŠ¨å»é‡</td>
    </tr>
    <tr>
      <td>è®¡æ•°</td>
      <td>Map</td>
      <td>é”®å€¼å¯¹å­˜å‚¨</td>
    </tr>
    <tr>
      <td>ç¼“å­˜</td>
      <td>Map</td>
      <td>ä¿æŒé¡ºåº</td>
    </tr>
    <tr>
      <td>DOM ç¼“å­˜</td>
      <td>WeakMap</td>
      <td>è‡ªåŠ¨ GC</td>
    </tr>
    <tr>
      <td>æœ‰åºéå†</td>
      <td>Map</td>
      <td>æ’å…¥é¡ºåº</td>
    </tr>
    <tr>
      <td>å°æ•°æ®é‡</td>
      <td>Object/Array</td>
      <td>æ›´ç®€å•</td>
    </tr>
  </tbody>
</table>

### å¸¸è§é™·é˜±

1. **å¯¹è±¡é”®çš„ç±»å‹**:
```typescript
// âŒ Object åªèƒ½ç”¨å­—ç¬¦ä¸²é”®
const obj: any = {};
obj[{ id: 1 }] = 'value';
console.log(obj); // { '[object Object]': 'value' }

// âœ… Map å¯ä»¥ç”¨ä»»æ„ç±»å‹
const map = new Map();
map.set({ id: 1 }, 'value');
```

2. **Set çš„ç›¸ç­‰åˆ¤æ–­**:
```typescript
const set = new Set();
set.add({ id: 1 });
set.add({ id: 1 });
console.log(set.size); // 2 (å¯¹è±¡å¼•ç”¨ä¸åŒ!)

// è§£å†³æ–¹æ¡ˆ:ä½¿ç”¨å­—ç¬¦ä¸²é”®
const set2 = new Set();
set2.add(JSON.stringify({ id: 1 }));
set2.add(JSON.stringify({ id: 1 }));
console.log(set2.size); // 1
```

3. **WeakMap çš„é”®å¿…é¡»æ˜¯å¯¹è±¡**:
```typescript
const weak = new WeakMap();
weak.set('key', 'value'); // âŒ TypeError
weak.set({}, 'value');    // âœ… æ­£ç¡®
```

### æ€§èƒ½ä¼˜åŒ–å»ºè®®

- âœ… å¤§é‡æŸ¥æ‰¾æ“ä½œç”¨ Set/Map
- âœ… é¿å…é¢‘ç¹çš„å“ˆå¸Œè®¡ç®—
- âœ… ä½¿ç”¨ WeakMap/WeakSet é¿å…å†…å­˜æ³„æ¼
- âœ… å°æ•°æ®é‡ å¯ä»¥ç”¨ Array/Object
- âœ… å®šæœŸæ¸…ç†è¿‡æœŸç¼“å­˜

### è¿›é˜¶å­¦ä¹ 

1. **å¸ƒéš†è¿‡æ»¤å™¨**: ç©ºé—´é«˜æ•ˆçš„æ¦‚ç‡å‹æ•°æ®ç»“æ„
2. **ä¸€è‡´æ€§å“ˆå¸Œ**: åˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„è´Ÿè½½å‡è¡¡
3. **å®Œç¾å“ˆå¸Œ**: æ— å†²çªçš„å“ˆå¸Œå‡½æ•°
4. **Cuckoo Hashing**: å¤šä¸ªå“ˆå¸Œå‡½æ•°å‡å°‘å†²çª

---

## ä¸‹æœŸé¢„å‘Š

ä¸‹ä¸€ç¯‡æˆ‘ä»¬å°†å­¦ä¹ **å †ä¸ä¼˜å…ˆé˜Ÿåˆ—**,æ¢è®¨:
- æœ€å°å †/æœ€å¤§å †çš„å®ç°
- ä¼˜å…ˆé˜Ÿåˆ—çš„åº”ç”¨
- Top K é—®é¢˜
- ä»»åŠ¡è°ƒåº¦ç³»ç»Ÿ

---

**ç›¸å…³èµ„æº**:
- [MDN: Map](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map)
- [MDN: Set](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set)
