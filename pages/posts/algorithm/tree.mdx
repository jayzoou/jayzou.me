
# æ ‘ç»“æ„åŸºç¡€ - äºŒå‰æ ‘éå†ä¸åº”ç”¨

## ä¸€ã€é—®é¢˜å¼•å…¥

ä½œä¸ºå‰ç«¯å¼€å‘å·¥ç¨‹å¸ˆ,ä½ æ¯å¤©éƒ½åœ¨å’Œæ ‘ç»“æ„æ‰“äº¤é“:

### åœºæ™¯1: DOM æ ‘æ“ä½œ
```html
<div id="root">
  <header>
    <nav>
      <ul>
        <li>é¦–é¡µ</li>
        <li>å…³äº</li>
      </ul>
    </nav>
  </header>
  <main>
    <article>å†…å®¹</article>
  </main>
</div>
```

```javascript
// å¦‚ä½•éå†æ‰€æœ‰èŠ‚ç‚¹?
// å¦‚ä½•æŸ¥æ‰¾ç‰¹å®šèŠ‚ç‚¹?
// å¦‚ä½•è®¡ç®—æ ‘çš„æ·±åº¦?
```

### åœºæ™¯2: React/Vue ç»„ä»¶æ ‘
```jsx
<App>
  <Header>
    <Nav />
    <Logo />
  </Header>
  <Main>
    <Sidebar />
    <Content />
  </Main>
  <Footer />
</App>
```

```javascript
// React Fiber å¦‚ä½•éå†ç»„ä»¶æ ‘?
// è™šæ‹Ÿ DOM diff ç®—æ³•å¦‚ä½•å·¥ä½œ?
// å¦‚ä½•å®ç°ç»„ä»¶æ ‘çš„æ·±åº¦ä¼˜å…ˆ/å¹¿åº¦ä¼˜å…ˆéå†?
```

### åœºæ™¯3: æ–‡ä»¶ç³»ç»Ÿæ ‘
```
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ Header.tsx
â”‚   â””â”€â”€ Footer.tsx
â”œâ”€â”€ utils/
â”‚   â””â”€â”€ helpers.ts
â””â”€â”€ App.tsx
```

```javascript
// å¦‚ä½•é€’å½’è¯»å–æ‰€æœ‰æ–‡ä»¶?
// å¦‚ä½•è®¡ç®—ç›®å½•å¤§å°?
// å¦‚ä½•å®ç°æ–‡ä»¶æœç´¢?
```

### åœºæ™¯4: è·¯ç”±é…ç½®æ ‘
```javascript
const routes = [
  {
    path: '/',
    children: [
      { path: 'home', component: Home },
      { 
        path: 'user',
        children: [
          { path: 'profile', component: Profile },
          { path: 'settings', component: Settings }
        ]
      }
    ]
  }
];

// å¦‚ä½•åŒ¹é…è·¯ç”±?
// å¦‚ä½•ç”Ÿæˆé¢åŒ…å±‘å¯¼èˆª?
```

ä»Šå¤©æˆ‘ä»¬å°†æ·±å…¥å­¦ä¹ æ ‘ç»“æ„,æŒæ¡å‰ç«¯å¼€å‘ä¸­æœ€é‡è¦çš„æ•°æ®ç»“æ„ä¹‹ä¸€ã€‚

---

## äºŒã€ç®—æ³•åŸç†

### ä»€ä¹ˆæ˜¯æ ‘?

æ ‘æ˜¯ä¸€ç§**å±‚æ¬¡åŒ–**çš„æ•°æ®ç»“æ„,ç”±èŠ‚ç‚¹ç»„æˆ:

```
æ ‘çš„åŸºæœ¬æ¦‚å¿µ:

        1          â† æ ¹èŠ‚ç‚¹ (root)
      / \
      2   3        â† ç¬¬2å±‚
    / \   \
    4   5   6      â† ç¬¬3å±‚ (å¶å­èŠ‚ç‚¹)

- æ ¹èŠ‚ç‚¹: æœ€é¡¶å±‚çš„èŠ‚ç‚¹ (1)
- çˆ¶èŠ‚ç‚¹: æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ (1, 2, 3)
- å­èŠ‚ç‚¹: æŸèŠ‚ç‚¹çš„ç›´æ¥ä¸‹çº§ (2å’Œ3æ˜¯1çš„å­èŠ‚ç‚¹)
- å¶å­èŠ‚ç‚¹: æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ (4, 5, 6)
- å…„å¼ŸèŠ‚ç‚¹: åŒä¸€çˆ¶èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ (2å’Œ3)
- æ·±åº¦: ä»æ ¹åˆ°è¯¥èŠ‚ç‚¹çš„è¾¹æ•° (4çš„æ·±åº¦æ˜¯2)
- é«˜åº¦: ä»è¯¥èŠ‚ç‚¹åˆ°å¶å­çš„æœ€é•¿è·¯å¾„ (1çš„é«˜åº¦æ˜¯2)
- å±‚æ•°: æ·±åº¦ + 1
```

### äºŒå‰æ ‘

æ¯ä¸ªèŠ‚ç‚¹æœ€å¤šæœ‰**ä¸¤ä¸ªå­èŠ‚ç‚¹**çš„æ ‘:

```
äºŒå‰æ ‘:
        1
      / \
      2   3
    / \
    4   5

- å·¦å­æ ‘: 2, 4, 5
- å³å­æ ‘: 3
```

### ç‰¹æ®Šçš„äºŒå‰æ ‘

#### 1. æ»¡äºŒå‰æ ‘
```
æ¯å±‚éƒ½æ˜¯æ»¡çš„:
        1
      / \
      2   3
    / \ / \
    4  5 6  7
```

#### 2. å®Œå…¨äºŒå‰æ ‘
```
é™¤æœ€åä¸€å±‚å¤–éƒ½æ˜¯æ»¡çš„,æœ€åä¸€å±‚ä»å·¦åˆ°å³è¿ç»­:
        1
      / \
      2   3
    / \ /
    4  5 6
```

#### 3. äºŒå‰æœç´¢æ ‘ (BST)
```
å·¦å­æ ‘ < æ ¹èŠ‚ç‚¹ < å³å­æ ‘:
        5
      / \
      3   7
    / \ / \
    2  4 6  8
```

---

## ä¸‰ã€äºŒå‰æ ‘éå†

### 1. æ·±åº¦ä¼˜å…ˆéå† (DFS)

#### å‰åºéå† (Pre-order): æ ¹ â†’ å·¦ â†’ å³

```
è®¿é—®é¡ºåº:
        1          1. è®¿é—®æ ¹èŠ‚ç‚¹ 1
      / \         2. éå†å·¦å­æ ‘ (2, 4, 5)
      2   3        3. éå†å³å­æ ‘ (3, 6, 7)
    / \ / \
    4  5 6  7      ç»“æœ: 1, 2, 4, 5, 3, 6, 7
```

**åº”ç”¨åœºæ™¯**:
- å¤åˆ¶æ ‘
- å‰ç¼€è¡¨è¾¾å¼æ±‚å€¼
- ç›®å½•æ ‘çš„å…ˆåºéå†

#### ä¸­åºéå† (In-order): å·¦ â†’ æ ¹ â†’ å³

```
è®¿é—®é¡ºåº:
        1          1. éå†å·¦å­æ ‘ (4, 2, 5)
      / \         2. è®¿é—®æ ¹èŠ‚ç‚¹ 1
      2   3        3. éå†å³å­æ ‘ (6, 3, 7)
    / \ / \
    4  5 6  7      ç»“æœ: 4, 2, 5, 1, 6, 3, 7
```

**åº”ç”¨åœºæ™¯**:
- äºŒå‰æœç´¢æ ‘æ’åº(å‡åº)
- è¡¨è¾¾å¼æ ‘æ±‚å€¼

#### ååºéå† (Post-order): å·¦ â†’ å³ â†’ æ ¹

```
è®¿é—®é¡ºåº:
        1          1. éå†å·¦å­æ ‘ (4, 5, 2)
      / \         2. éå†å³å­æ ‘ (6, 7, 3)
      2   3        3. è®¿é—®æ ¹èŠ‚ç‚¹ 1
    / \ / \
    4  5 6  7      ç»“æœ: 4, 5, 2, 6, 7, 3, 1
```

**åº”ç”¨åœºæ™¯**:
- åˆ é™¤æ ‘
- åç¼€è¡¨è¾¾å¼æ±‚å€¼
- è®¡ç®—ç›®å½•å¤§å°

### 2. å¹¿åº¦ä¼˜å…ˆéå† (BFS)

#### å±‚åºéå† (Level-order): é€å±‚è®¿é—®

```
è®¿é—®é¡ºåº:
        1          ç¬¬1å±‚: 1
      / \         ç¬¬2å±‚: 2, 3
      2   3        ç¬¬3å±‚: 4, 5, 6, 7
    / \ / \
    4  5 6  7      ç»“æœ: 1, 2, 3, 4, 5, 6, 7
```

**åº”ç”¨åœºæ™¯**:
- æŸ¥æ‰¾æœ€çŸ­è·¯å¾„
- å±‚çº§å…³ç³»å¤„ç†
- ç»„ä»¶æ ‘æ¸²æŸ“

---

## å››ã€ä»£ç å®ç°

### 1. äºŒå‰æ ‘èŠ‚ç‚¹å®šä¹‰

```typescript
/**
  * äºŒå‰æ ‘èŠ‚ç‚¹
  */
class TreeNode<T> {
  value: T;
  left: TreeNode<T> | null = null;
  right: TreeNode<T> | null = null;
  
  constructor(value: T) {
    this.value = value;
  }
}

/**
  * äºŒå‰æ ‘
  */
class BinaryTree<T> {
  root: TreeNode<T> | null = null;
  
  constructor(value?: T) {
    if (value !== undefined) {
      this.root = new TreeNode(value);
    }
  }
}
```

---

### 2. å‰åºéå†

```typescript
/**
  * å‰åºéå† - é€’å½’ç‰ˆæœ¬
  */
function preorderTraversal<T>(root: TreeNode<T> | null): T[] {
  const result: T[] = [];
  
  function traverse(node: TreeNode<T> | null) {
    if (!node) return;
    
    result.push(node.value);      // æ ¹
    traverse(node.left);           // å·¦
    traverse(node.right);          // å³
  }
  
  traverse(root);
  return result;
}

/**
  * å‰åºéå† - è¿­ä»£ç‰ˆæœ¬(ä½¿ç”¨æ ˆ)
  */
function preorderTraversalIterative<T>(root: TreeNode<T> | null): T[] {
  if (!root) return [];
  
  const result: T[] = [];
  const stack: TreeNode<T>[] = [root];
  
  while (stack.length > 0) {
    const node = stack.pop()!;
    result.push(node.value);
    
    // å…ˆå‹å³å­æ ‘,å†å‹å·¦å­æ ‘(æ ˆæ˜¯åè¿›å…ˆå‡º)
    if (node.right) stack.push(node.right);
    if (node.left) stack.push(node.left);
  }
  
  return result;
}

// æµ‹è¯•
const tree = new BinaryTree(1);
tree.root!.left = new TreeNode(2);
tree.root!.right = new TreeNode(3);
tree.root!.left.left = new TreeNode(4);
tree.root!.left.right = new TreeNode(5);

console.log(preorderTraversal(tree.root));
// [1, 2, 4, 5, 3]

console.log(preorderTraversalIterative(tree.root));
// [1, 2, 4, 5, 3]
```

**å¯è§†åŒ–æ ˆçš„è¿‡ç¨‹**:
```
æ ‘:     1
        / \
      2   3
      / \
    4   5

è¿­ä»£è¿‡ç¨‹:
1. stack=[1], result=[]
2. pop 1, stack=[3,2], result=[1]
3. pop 2, stack=[3,5,4], result=[1,2]
4. pop 4, stack=[3,5], result=[1,2,4]
5. pop 5, stack=[3], result=[1,2,4,5]
6. pop 3, stack=[], result=[1,2,4,5,3]
```

---

### 3. ä¸­åºéå†

```typescript
/**
  * ä¸­åºéå† - é€’å½’ç‰ˆæœ¬
  */
function inorderTraversal<T>(root: TreeNode<T> | null): T[] {
  const result: T[] = [];
  
  function traverse(node: TreeNode<T> | null) {
    if (!node) return;
    
    traverse(node.left);           // å·¦
    result.push(node.value);       // æ ¹
    traverse(node.right);          // å³
  }
  
  traverse(root);
  return result;
}

/**
  * ä¸­åºéå† - è¿­ä»£ç‰ˆæœ¬
  */
function inorderTraversalIterative<T>(root: TreeNode<T> | null): T[] {
  const result: T[] = [];
  const stack: TreeNode<T>[] = [];
  let current = root;
  
  while (current || stack.length > 0) {
    // ä¸€ç›´å‘å·¦èµ°åˆ°åº•
    while (current) {
      stack.push(current);
      current = current.left;
    }
    
    // å¼¹å‡ºæ ˆé¡¶(æœ€å·¦èŠ‚ç‚¹)
    current = stack.pop()!;
    result.push(current.value);
    
    // è½¬å‘å³å­æ ‘
    current = current.right;
  }
  
  return result;
}

// æµ‹è¯•
console.log(inorderTraversal(tree.root));
// [4, 2, 5, 1, 3]
```

**å¯è§†åŒ–è¿‡ç¨‹**:
```
æ ‘:     1
        / \
      2   3
      / \
    4   5

è¿­ä»£è¿‡ç¨‹:
1. current=1, stack=[], result=[]
2. å‘å·¦: current=2, stack=[1], result=[]
3. å‘å·¦: current=4, stack=[1,2], result=[]
4. å‘å·¦: current=null, stack=[1,2,4], result=[]
5. pop 4: current=4, stack=[1,2], result=[4]
6. å³å­æ ‘: current=null
7. pop 2: current=2, stack=[1], result=[4,2]
8. å³å­æ ‘: current=5, stack=[1]
9. å‘å·¦: current=null, stack=[1,5]
10. pop 5: current=5, stack=[1], result=[4,2,5]
11. å³å­æ ‘: current=null
12. pop 1: current=1, stack=[], result=[4,2,5,1]
13. å³å­æ ‘: current=3, stack=[]
14. å‘å·¦: current=null, stack=[3]
15. pop 3: current=3, stack=[], result=[4,2,5,1,3]
```

---

### 4. ååºéå†

```typescript
/**
  * ååºéå† - é€’å½’ç‰ˆæœ¬
  */
function postorderTraversal<T>(root: TreeNode<T> | null): T[] {
  const result: T[] = [];
  
  function traverse(node: TreeNode<T> | null) {
    if (!node) return;
    
    traverse(node.left);           // å·¦
    traverse(node.right);          // å³
    result.push(node.value);       // æ ¹
  }
  
  traverse(root);
  return result;
}

/**
  * ååºéå† - è¿­ä»£ç‰ˆæœ¬(åŒæ ˆæ³•)
  */
function postorderTraversalIterative<T>(root: TreeNode<T> | null): T[] {
  if (!root) return [];
  
  const result: T[] = [];
  const stack1: TreeNode<T>[] = [root];
  const stack2: TreeNode<T>[] = [];
  
  // ç¬¬ä¸€ä¸ªæ ˆ:æ ¹ â†’ å³ â†’ å·¦ (å‰åºçš„é•œåƒ)
  while (stack1.length > 0) {
    const node = stack1.pop()!;
    stack2.push(node);
    
    if (node.left) stack1.push(node.left);
    if (node.right) stack1.push(node.right);
  }
  
  // ç¬¬äºŒä¸ªæ ˆåè½¬,å¾—åˆ°ååº
  while (stack2.length > 0) {
    result.push(stack2.pop()!.value);
  }
  
  return result;
}

// æµ‹è¯•
console.log(postorderTraversal(tree.root));
// [4, 5, 2, 3, 1]
```

---

### 5. å±‚åºéå†

```typescript
/**
  * å±‚åºéå† - ä½¿ç”¨é˜Ÿåˆ—
  */
function levelOrderTraversal<T>(root: TreeNode<T> | null): T[] {
  if (!root) return [];
  
  const result: T[] = [];
  const queue: TreeNode<T>[] = [root];
  
  while (queue.length > 0) {
    const node = queue.shift()!;
    result.push(node.value);
    
    if (node.left) queue.push(node.left);
    if (node.right) queue.push(node.right);
  }
  
  return result;
}

/**
  * å±‚åºéå† - è¿”å›äºŒç»´æ•°ç»„(æŒ‰å±‚åˆ†ç»„)
  */
function levelOrderTraversalByLevel<T>(root: TreeNode<T> | null): T[][] {
  if (!root) return [];
  
  const result: T[][] = [];
  const queue: TreeNode<T>[] = [root];
  
  while (queue.length > 0) {
    const levelSize = queue.length;
    const currentLevel: T[] = [];
    
    // å¤„ç†å½“å‰å±‚çš„æ‰€æœ‰èŠ‚ç‚¹
    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift()!;
      currentLevel.push(node.value);
      
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
    
    result.push(currentLevel);
  }
  
  return result;
}

// æµ‹è¯•
console.log(levelOrderTraversal(tree.root));
// [1, 2, 3, 4, 5]

console.log(levelOrderTraversalByLevel(tree.root));
// [[1], [2, 3], [4, 5]]
```

**å¯è§†åŒ–é˜Ÿåˆ—è¿‡ç¨‹**:
```
æ ‘:     1
        / \
      2   3
      / \
    4   5

è¿‡ç¨‹:
1. queue=[1], result=[]
2. dequeue 1, queue=[2,3], result=[1]
3. dequeue 2, queue=[3,4,5], result=[1,2]
4. dequeue 3, queue=[4,5], result=[1,2,3]
5. dequeue 4, queue=[5], result=[1,2,3,4]
6. dequeue 5, queue=[], result=[1,2,3,4,5]
```

---

### 6. æ ‘çš„åŸºæœ¬æ“ä½œ

```typescript
/**
  * è®¡ç®—æ ‘çš„æœ€å¤§æ·±åº¦
  */
function maxDepth<T>(root: TreeNode<T> | null): number {
  if (!root) return 0;
  
  const leftDepth = maxDepth(root.left);
  const rightDepth = maxDepth(root.right);
  
  return Math.max(leftDepth, rightDepth) + 1;
}

/**
  * è®¡ç®—æ ‘çš„æœ€å°æ·±åº¦
  */
function minDepth<T>(root: TreeNode<T> | null): number {
  if (!root) return 0;
  
  // å¦‚æœåªæœ‰ä¸€ä¸ªå­æ ‘,è¿”å›è¯¥å­æ ‘çš„æ·±åº¦
  if (!root.left) return minDepth(root.right) + 1;
  if (!root.right) return minDepth(root.left) + 1;
  
  return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
}

/**
  * è®¡ç®—èŠ‚ç‚¹æ€»æ•°
  */
function countNodes<T>(root: TreeNode<T> | null): number {
  if (!root) return 0;
  
  return 1 + countNodes(root.left) + countNodes(root.right);
}

/**
  * è®¡ç®—å¶å­èŠ‚ç‚¹æ•°
  */
function countLeaves<T>(root: TreeNode<T> | null): number {
  if (!root) return 0;
  
  // å¶å­èŠ‚ç‚¹:æ²¡æœ‰å·¦å³å­æ ‘
  if (!root.left && !root.right) return 1;
  
  return countLeaves(root.left) + countLeaves(root.right);
}

/**
  * åˆ¤æ–­æ˜¯å¦ä¸ºå¹³è¡¡äºŒå‰æ ‘
  */
function isBalanced<T>(root: TreeNode<T> | null): boolean {
  function checkHeight(node: TreeNode<T> | null): number {
    if (!node) return 0;
    
    const leftHeight = checkHeight(node.left);
    if (leftHeight === -1) return -1; // å·¦å­æ ‘ä¸å¹³è¡¡
    
    const rightHeight = checkHeight(node.right);
    if (rightHeight === -1) return -1; // å³å­æ ‘ä¸å¹³è¡¡
    
    // å·¦å³å­æ ‘é«˜åº¦å·®è¶…è¿‡1,ä¸å¹³è¡¡
    if (Math.abs(leftHeight - rightHeight) > 1) return -1;
    
    return Math.max(leftHeight, rightHeight) + 1;
  }
  
  return checkHeight(root) !== -1;
}

/**
  * åˆ¤æ–­æ˜¯å¦ä¸ºå¯¹ç§°äºŒå‰æ ‘
  */
function isSymmetric<T>(root: TreeNode<T> | null): boolean {
  function isMirror(
    left: TreeNode<T> | null,
    right: TreeNode<T> | null
  ): boolean {
    if (!left && !right) return true;
    if (!left || !right) return false;
    
    return (
      left.value === right.value &&
      isMirror(left.left, right.right) &&
      isMirror(left.right, right.left)
    );
  }
  
  if (!root) return true;
  return isMirror(root.left, root.right);
}

/**
  * ç¿»è½¬äºŒå‰æ ‘
  */
function invertTree<T>(root: TreeNode<T> | null): TreeNode<T> | null {
  if (!root) return null;
  
  // äº¤æ¢å·¦å³å­æ ‘
  [root.left, root.right] = [root.right, root.left];
  
  // é€’å½’ç¿»è½¬å­æ ‘
  invertTree(root.left);
  invertTree(root.right);
  
  return root;
}

// æµ‹è¯•
console.log('æœ€å¤§æ·±åº¦:', maxDepth(tree.root));        // 3
console.log('æœ€å°æ·±åº¦:', minDepth(tree.root));        // 2
console.log('èŠ‚ç‚¹æ€»æ•°:', countNodes(tree.root));      // 5
console.log('å¶å­èŠ‚ç‚¹æ•°:', countLeaves(tree.root));   // 3
console.log('æ˜¯å¦å¹³è¡¡:', isBalanced(tree.root));      // true
```

---

### 7. è·¯å¾„é—®é¢˜

```typescript
/**
  * äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„
  */
function binaryTreePaths<T>(root: TreeNode<T> | null): string[] {
  const paths: string[] = [];
  
  function dfs(node: TreeNode<T> | null, path: string) {
    if (!node) return;
    
    path += node.value;
    
    // å¶å­èŠ‚ç‚¹,è®°å½•è·¯å¾„
    if (!node.left && !node.right) {
      paths.push(path);
      return;
    }
    
    // ç»§ç»­éå†
    path += '->';
    dfs(node.left, path);
    dfs(node.right, path);
  }
  
  dfs(root, '');
  return paths;
}

/**
  * è·¯å¾„æ€»å’Œ
  */
function hasPathSum<T>(root: TreeNode<number> | null, targetSum: number): boolean {
  if (!root) return false;
  
  // å¶å­èŠ‚ç‚¹,æ£€æŸ¥æ˜¯å¦ç­‰äºç›®æ ‡å’Œ
  if (!root.left && !root.right) {
    return root.value === targetSum;
  }
  
  // é€’å½’æ£€æŸ¥å­æ ‘
  return (
    hasPathSum(root.left, targetSum - root.value) ||
    hasPathSum(root.right, targetSum - root.value)
  );
}

/**
  * è·¯å¾„æ€»å’Œ II - è¿”å›æ‰€æœ‰è·¯å¾„
  */
function pathSum(root: TreeNode<number> | null, targetSum: number): number[][] {
  const result: number[][] = [];
  
  function dfs(node: TreeNode<number> | null, sum: number, path: number[]) {
    if (!node) return;
    
    path.push(node.value);
    
    // å¶å­èŠ‚ç‚¹ä¸”å’Œç­‰äºç›®æ ‡
    if (!node.left && !node.right && sum === node.value) {
      result.push([...path]); // å¤åˆ¶è·¯å¾„
    }
    
    // ç»§ç»­éå†
    dfs(node.left, sum - node.value, path);
    dfs(node.right, sum - node.value, path);
    
    // å›æº¯
    path.pop();
  }
  
  dfs(root, targetSum, []);
  return result;
}

// æµ‹è¯•
console.log(binaryTreePaths(tree.root));
// ["1->2->4", "1->2->5", "1->3"]
```

---

## äº”ã€å¤æ‚åº¦åˆ†æ

### éå†ç®—æ³•å¤æ‚åº¦

<table>
  <thead>
    <tr>
      <th>éå†æ–¹å¼</th>
      <th>æ—¶é—´å¤æ‚åº¦</th>
      <th>ç©ºé—´å¤æ‚åº¦</th>
      <th>è¯´æ˜</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>å‰åºéå†(é€’å½’)</td>
      <td>O(n)</td>
      <td>O(h)</td>
      <td>h ä¸ºæ ‘é«˜</td>
    </tr>
    <tr>
      <td>å‰åºéå†(è¿­ä»£)</td>
      <td>O(n)</td>
      <td>O(h)</td>
      <td>æ ˆç©ºé—´</td>
    </tr>
    <tr>
      <td>ä¸­åºéå†(é€’å½’)</td>
      <td>O(n)</td>
      <td>O(h)</td>
      <td>h ä¸ºæ ‘é«˜</td>
    </tr>
    <tr>
      <td>ä¸­åºéå†(è¿­ä»£)</td>
      <td>O(n)</td>
      <td>O(h)</td>
      <td>æ ˆç©ºé—´</td>
    </tr>
    <tr>
      <td>ååºéå†(é€’å½’)</td>
      <td>O(n)</td>
      <td>O(h)</td>
      <td>h ä¸ºæ ‘é«˜</td>
    </tr>
    <tr>
      <td>ååºéå†(è¿­ä»£)</td>
      <td>O(n)</td>
      <td>O(h)</td>
      <td>æ ˆç©ºé—´</td>
    </tr>
    <tr>
      <td>å±‚åºéå†</td>
      <td>O(n)</td>
      <td>O(w)</td>
      <td>w ä¸ºæœ€å¤§å®½åº¦</td>
    </tr>
  </tbody>
</table>

### æ ‘çš„é«˜åº¦ä¸èŠ‚ç‚¹æ•°å…³ç³»

```
å®Œå…¨äºŒå‰æ ‘:
- é«˜åº¦ h, èŠ‚ç‚¹æ•° n
- 2^h â‰¤ n < 2^(h+1)
- h = âŒŠlogâ‚‚(n)âŒ‹

å¹³è¡¡äºŒå‰æ ‘:
- é«˜åº¦ h = O(log n)

æ–œæ ‘(é€€åŒ–æˆé“¾è¡¨):
- é«˜åº¦ h = O(n)
```

### é€’å½’ vs è¿­ä»£

<table>
  <thead>
    <tr>
      <th>æ–¹å¼</th>
      <th>ä¼˜ç‚¹</th>
      <th>ç¼ºç‚¹</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>é€’å½’</td>
      <td>ä»£ç ç®€æ´,æ˜“ç†è§£</td>
      <td>å¯èƒ½æ ˆæº¢å‡º,ç©ºé—´å¼€é”€å¤§</td>
    </tr>
    <tr>
      <td>è¿­ä»£</td>
      <td>ç©ºé—´å¯æ§,ä¸ä¼šæ ˆæº¢å‡º</td>
      <td>ä»£ç å¤æ‚,éœ€è¦æ‰‹åŠ¨ç»´æŠ¤æ ˆ/é˜Ÿåˆ—</td>
    </tr>
  </tbody>
</table>

---

## å…­ã€å®æˆ˜åº”ç”¨

### æ¡ˆä¾‹1: DOM æ ‘éå†

```typescript
/**
  * DOM æ ‘èŠ‚ç‚¹
  */
interface DOMNode {
  tagName: string;
  children: DOMNode[];
  attributes?: Record<string, string>;
}

/**
  * DOM æ ‘éå†å™¨
  */
class DOMTreeTraverser {
  /**
    * æ·±åº¦ä¼˜å…ˆéå†(å‰åº)
    */
  static dfs(node: DOMNode, callback: (node: DOMNode) => void): void {
    callback(node);
    
    for (const child of node.children) {
      this.dfs(child, callback);
    }
  }
  
  /**
    * å¹¿åº¦ä¼˜å…ˆéå†
    */
  static bfs(node: DOMNode, callback: (node: DOMNode) => void): void {
    const queue: DOMNode[] = [node];
    
    while (queue.length > 0) {
      const current = queue.shift()!;
      callback(current);
      
      queue.push(...current.children);
    }
  }
  
  /**
    * æŸ¥æ‰¾èŠ‚ç‚¹
    */
  static find(
    node: DOMNode,
    predicate: (node: DOMNode) => boolean
  ): DOMNode | null {
    if (predicate(node)) {
      return node;
    }
    
    for (const child of node.children) {
      const found = this.find(child, predicate);
      if (found) return found;
    }
    
    return null;
  }
  
  /**
    * è®¡ç®—æ ‘çš„æ·±åº¦
    */
  static depth(node: DOMNode): number {
    if (node.children.length === 0) {
      return 1;
    }
    
    return 1 + Math.max(...node.children.map(child => this.depth(child)));
  }
  
  /**
    * è·å–æ‰€æœ‰å¶å­èŠ‚ç‚¹
    */
  static getLeaves(node: DOMNode): DOMNode[] {
    const leaves: DOMNode[] = [];
    
    function collect(n: DOMNode) {
      if (n.children.length === 0) {
        leaves.push(n);
      } else {
        n.children.forEach(collect);
      }
    }
    
    collect(node);
    return leaves;
  }
  
  /**
    * åºåˆ—åŒ–ä¸º HTML å­—ç¬¦ä¸²
    */
  static toHTML(node: DOMNode, indent: number = 0): string {
    const spaces = '  '.repeat(indent);
    const attrs = node.attributes
      ? ' ' + Object.entries(node.attributes)
          .map(([key, value]) => `${key}="${value}"`)
          .join(' ')
      : '';
    
    if (node.children.length === 0) {
      return `${spaces}<${node.tagName}${attrs} />`;
    }
    
    const childrenHTML = node.children
      .map(child => this.toHTML(child, indent + 1))
      .join('\n');
    
    return `${spaces}<${node.tagName}${attrs}>\n${childrenHTML}\n${spaces}</${node.tagName}>`;
  }
}

// æµ‹è¯•
const dom: DOMNode = {
  tagName: 'div',
  attributes: { id: 'root' },
  children: [
    {
      tagName: 'header',
      children: [
        { tagName: 'h1', children: [] },
        { tagName: 'nav', children: [] }
      ]
    },
    {
      tagName: 'main',
      children: [
        { tagName: 'article', children: [] }
      ]
    }
  ]
};

console.log('æ·±åº¦:', DOMTreeTraverser.depth(dom)); // 3

console.log('\nDFS éå†:');
DOMTreeTraverser.dfs(dom, node => {
  console.log(node.tagName);
});
// div, header, h1, nav, main, article

console.log('\nBFS éå†:');
DOMTreeTraverser.bfs(dom, node => {
  console.log(node.tagName);
});
// div, header, main, h1, nav, article

const found = DOMTreeTraverser.find(dom, node => node.tagName === 'nav');
console.log('\næ‰¾åˆ°èŠ‚ç‚¹:', found?.tagName); // nav

console.log('\nHTML:');
console.log(DOMTreeTraverser.toHTML(dom));
```

---

### æ¡ˆä¾‹2: æ–‡ä»¶ç³»ç»Ÿæ ‘

```typescript
/**
  * æ–‡ä»¶ç³»ç»ŸèŠ‚ç‚¹
  */
interface FileNode {
  name: string;
  type: 'file' | 'directory';
  size?: number;        // æ–‡ä»¶å¤§å°(å­—èŠ‚)
  children?: FileNode[];
}

/**
  * æ–‡ä»¶ç³»ç»Ÿæ ‘æ“ä½œ
  */
class FileSystemTree {
  /**
    * è®¡ç®—ç›®å½•æ€»å¤§å°
    */
  static calculateSize(node: FileNode): number {
    if (node.type === 'file') {
      return node.size || 0;
    }
    
    return (node.children || []).reduce(
      (sum, child) => sum + this.calculateSize(child),
      0
    );
  }
  
  /**
    * æŸ¥æ‰¾æ–‡ä»¶
    */
  static findFile(node: FileNode, fileName: string): FileNode | null {
    if (node.name === fileName) {
      return node;
    }
    
    if (node.type === 'directory' && node.children) {
      for (const child of node.children) {
        const found = this.findFile(child, fileName);
        if (found) return found;
      }
    }
    
    return null;
  }
  
  /**
    * è·å–æ–‡ä»¶è·¯å¾„
    */
  static getPath(root: FileNode, target: string): string | null {
    function dfs(node: FileNode, path: string): string | null {
      const currentPath = path + '/' + node.name;
      
      if (node.name === target) {
        return currentPath;
      }
      
      if (node.type === 'directory' && node.children) {
        for (const child of node.children) {
          const found = dfs(child, currentPath);
          if (found) return found;
        }
      }
      
      return null;
    }
    
    return dfs(root, '');
  }
  
  /**
    * åˆ—å‡ºæ‰€æœ‰æ–‡ä»¶
    */
  static listAllFiles(node: FileNode): string[] {
    const files: string[] = [];
    
    function collect(n: FileNode, path: string) {
      const currentPath = path + '/' + n.name;
      
      if (n.type === 'file') {
        files.push(currentPath);
      } else if (n.children) {
        n.children.forEach(child => collect(child, currentPath));
      }
    }
    
    collect(node, '');
    return files;
  }
  
  /**
    * æ‰“å°æ ‘ç»“æ„
    */
  static printTree(node: FileNode, indent: number = 0): void {
    const prefix = '  '.repeat(indent);
    const icon = node.type === 'directory' ? 'ğŸ“' : 'ğŸ“„';
    const size = node.type === 'file' ? ` (${node.size} bytes)` : '';
    
    console.log(`${prefix}${icon} ${node.name}${size}`);
    
    if (node.children) {
      node.children.forEach(child => this.printTree(child, indent + 1));
    }
  }
  
  /**
    * ç»Ÿè®¡ä¿¡æ¯
    */
  static getStats(node: FileNode): {
    totalFiles: number;
    totalDirs: number;
    totalSize: number;
    maxDepth: number;
  } {
    let totalFiles = 0;
    let totalDirs = 0;
    let maxDepth = 0;
    
    function traverse(n: FileNode, depth: number) {
      maxDepth = Math.max(maxDepth, depth);
      
      if (n.type === 'file') {
        totalFiles++;
      } else {
        totalDirs++;
        n.children?.forEach(child => traverse(child, depth + 1));
      }
    }
    
    traverse(node, 1);
    
    return {
      totalFiles,
      totalDirs,
      totalSize: this.calculateSize(node),
      maxDepth
    };
  }
}

// æµ‹è¯•
const fileSystem: FileNode = {
  name: 'src',
  type: 'directory',
  children: [
    {
      name: 'components',
      type: 'directory',
      children: [
        { name: 'Header.tsx', type: 'file', size: 1024 },
        { name: 'Footer.tsx', type: 'file', size: 512 }
      ]
    },
    {
      name: 'utils',
      type: 'directory',
      children: [
        { name: 'helpers.ts', type: 'file', size: 2048 }
      ]
    },
    { name: 'App.tsx', type: 'file', size: 4096 }
  ]
};

console.log('æ–‡ä»¶æ ‘ç»“æ„:');
FileSystemTree.printTree(fileSystem);
// ğŸ“ src
//   ğŸ“ components
//     ğŸ“„ Header.tsx (1024 bytes)
//     ğŸ“„ Footer.tsx (512 bytes)
//   ğŸ“ utils
//     ğŸ“„ helpers.ts (2048 bytes)
//   ğŸ“„ App.tsx (4096 bytes)

const stats = FileSystemTree.getStats(fileSystem);
console.log('\nç»Ÿè®¡ä¿¡æ¯:');
console.log('æ–‡ä»¶æ•°:', stats.totalFiles);      // 4
console.log('ç›®å½•æ•°:', stats.totalDirs);        // 3
console.log('æ€»å¤§å°:', stats.totalSize, 'bytes'); // 7680
console.log('æœ€å¤§æ·±åº¦:', stats.maxDepth);       // 3

const path = FileSystemTree.getPath(fileSystem, 'Header.tsx');
console.log('\næ–‡ä»¶è·¯å¾„:', path);
// /src/components/Header.tsx

const allFiles = FileSystemTree.listAllFiles(fileSystem);
console.log('\næ‰€æœ‰æ–‡ä»¶:');
allFiles.forEach(file => console.log(file));
```

---

### æ¡ˆä¾‹3: React ç»„ä»¶æ ‘éå†

```typescript
/**
  * React ç»„ä»¶èŠ‚ç‚¹(ç®€åŒ–ç‰ˆ)
  */
interface ComponentNode {
  type: string;
  props: Record<string, any>;
  children: ComponentNode[];
}

/**
  * React ç»„ä»¶æ ‘å·¥å…·
  */
class ComponentTree {
  /**
    * æŸ¥æ‰¾ç»„ä»¶
    */
  static findComponent(
    root: ComponentNode,
    type: string
  ): ComponentNode | null {
    if (root.type === type) {
      return root;
    }
    
    for (const child of root.children) {
      const found = this.findComponent(child, type);
      if (found) return found;
    }
    
    return null;
  }
  
  /**
    * æŸ¥æ‰¾æ‰€æœ‰åŒ¹é…çš„ç»„ä»¶
    */
  static findAllComponents(
    root: ComponentNode,
    type: string
  ): ComponentNode[] {
    const result: ComponentNode[] = [];
    
    function traverse(node: ComponentNode) {
      if (node.type === type) {
        result.push(node);
      }
      node.children.forEach(traverse);
    }
    
    traverse(root);
    return result;
  }
  
  /**
    * è®¡ç®—ç»„ä»¶æ ‘æ·±åº¦
    */
  static getDepth(root: ComponentNode): number {
    if (root.children.length === 0) {
      return 1;
    }
    
    return 1 + Math.max(...root.children.map(child => this.getDepth(child)));
  }
  
  /**
    * è·å–ç»„ä»¶è·¯å¾„
    */
  static getComponentPath(
    root: ComponentNode,
    targetType: string
  ): string[] | null {
    function dfs(node: ComponentNode, path: string[]): string[] | null {
      const currentPath = [...path, node.type];
      
      if (node.type === targetType) {
        return currentPath;
      }
      
      for (const child of node.children) {
        const found = dfs(child, currentPath);
        if (found) return found;
      }
      
      return null;
    }
    
    return dfs(root, []);
  }
  
  /**
    * æ‰“å°ç»„ä»¶æ ‘
    */
  static printTree(node: ComponentNode, indent: number = 0): void {
    const prefix = '  '.repeat(indent);
    const propsStr = Object.keys(node.props).length > 0
      ? ` ${JSON.stringify(node.props)}`
      : '';
    
    console.log(`${prefix}<${node.type}${propsStr}>`);
    node.children.forEach(child => this.printTree(child, indent + 1));
  }
  
  /**
    * ç»Ÿè®¡ç»„ä»¶æ•°é‡
    */
  static countComponents(root: ComponentNode): Map<string, number> {
    const counts = new Map<string, number>();
    
    function traverse(node: ComponentNode) {
      counts.set(node.type, (counts.get(node.type) || 0) + 1);
      node.children.forEach(traverse);
    }
    
    traverse(root);
    return counts;
  }
}

// æµ‹è¯•
const componentTree: ComponentNode = {
  type: 'App',
  props: {},
  children: [
    {
      type: 'Header',
      props: { title: 'My App' },
      children: [
        { type: 'Nav', props: {}, children: [] },
        { type: 'Logo', props: {}, children: [] }
      ]
    },
    {
      type: 'Main',
      props: {},
      children: [
        { type: 'Sidebar', props: {}, children: [] },
        { type: 'Content', props: {}, children: [] }
      ]
    },
    { type: 'Footer', props: {}, children: [] }
  ]
};

console.log('ç»„ä»¶æ ‘ç»“æ„:');
ComponentTree.printTree(componentTree);

console.log('\nç»„ä»¶æ·±åº¦:', ComponentTree.getDepth(componentTree)); // 3

const path = ComponentTree.getComponentPath(componentTree, 'Nav');
console.log('\nç»„ä»¶è·¯å¾„:', path?.join(' > '));
// App > Header > Nav

const counts = ComponentTree.countComponents(componentTree);
console.log('\nç»„ä»¶ç»Ÿè®¡:');
counts.forEach((count, type) => {
  console.log(`${type}: ${count}`);
});
```

---

## ä¸ƒã€ç»ƒä¹ é¢˜

### é¢˜ç›®1: äºŒå‰æ ‘çš„æœ€å¤§è·¯å¾„å’Œ (LeetCode 124)

**éš¾åº¦**: å›°éš¾

**é¢˜ç›®æè¿°**:
è·¯å¾„è¢«å®šä¹‰ä¸ºä¸€æ¡ä»æ ‘ä¸­ä»»æ„èŠ‚ç‚¹å‡ºå‘,æ²¿çˆ¶èŠ‚ç‚¹-å­èŠ‚ç‚¹è¿æ¥,è¾¾åˆ°ä»»æ„èŠ‚ç‚¹çš„åºåˆ—ã€‚åŒä¸€ä¸ªèŠ‚ç‚¹åœ¨ä¸€æ¡è·¯å¾„åºåˆ—ä¸­è‡³å¤šå‡ºç°ä¸€æ¬¡ã€‚è¯¥è·¯å¾„è‡³å°‘åŒ…å«ä¸€ä¸ªèŠ‚ç‚¹,ä¸”ä¸ä¸€å®šç»è¿‡æ ¹èŠ‚ç‚¹ã€‚

```typescript
/**
  * @param root - äºŒå‰æ ‘æ ¹èŠ‚ç‚¹
  * @return æœ€å¤§è·¯å¾„å’Œ
  */
function maxPathSum(root: TreeNode<number> | null): number {
  // åœ¨è¿™é‡Œå®ç°ä½ çš„ä»£ç 
}

// æµ‹è¯•ç”¨ä¾‹
// è¾“å…¥:    1
//        / \
//       2   3
// è¾“å‡º: 6 (2 + 1 + 3)
```

**æç¤º**: å¯¹äºæ¯ä¸ªèŠ‚ç‚¹,æœ€å¤§è·¯å¾„å’Œå¯èƒ½æ˜¯:
1. å·¦å­æ ‘æœ€å¤§è·¯å¾„ + å½“å‰èŠ‚ç‚¹
2. å³å­æ ‘æœ€å¤§è·¯å¾„ + å½“å‰èŠ‚ç‚¹
3. å·¦å­æ ‘ + å½“å‰èŠ‚ç‚¹ + å³å­æ ‘

---

### é¢˜ç›®2: äºŒå‰æ ‘çš„å³è§†å›¾ (LeetCode 199)

**éš¾åº¦**: ä¸­ç­‰

**é¢˜ç›®æè¿°**:
ç»™å®šä¸€ä¸ªäºŒå‰æ ‘,æƒ³è±¡è‡ªå·±ç«™åœ¨å®ƒçš„å³ä¾§,è¿”å›ä»å³ä¾§æ‰€èƒ½çœ‹åˆ°çš„èŠ‚ç‚¹å€¼ã€‚

```typescript
/**
  * @param root - äºŒå‰æ ‘æ ¹èŠ‚ç‚¹
  * @return å³è§†å›¾èŠ‚ç‚¹å€¼æ•°ç»„
  */
function rightSideView(root: TreeNode<number> | null): number[] {
  // åœ¨è¿™é‡Œå®ç°ä½ çš„ä»£ç 
}

// æµ‹è¯•ç”¨ä¾‹
// è¾“å…¥:    1
//        /   \
//       2     3
//        \     \
//         5     4
// è¾“å‡º: [1, 3, 4]
```

**æç¤º**: ä½¿ç”¨å±‚åºéå†,æ¯å±‚å–æœ€åä¸€ä¸ªèŠ‚ç‚¹

---

### é¢˜ç›®3: äºŒå‰æ ‘çš„åºåˆ—åŒ–ä¸ååºåˆ—åŒ– (LeetCode 297)

**éš¾åº¦**: å›°éš¾

**é¢˜ç›®æè¿°**:
è®¾è®¡ç®—æ³•æ¥åºåˆ—åŒ–å’Œååºåˆ—åŒ–äºŒå‰æ ‘ã€‚

```typescript
/**
  * åºåˆ—åŒ–
  */
function serialize(root: TreeNode<number> | null): string {
  // åœ¨è¿™é‡Œå®ç°ä½ çš„ä»£ç 
}

/**
  * ååºåˆ—åŒ–
  */
function deserialize(data: string): TreeNode<number> | null {
  // åœ¨è¿™é‡Œå®ç°ä½ çš„ä»£ç 
}

// æµ‹è¯•ç”¨ä¾‹
// è¾“å…¥:    1
//        / \
//       2   3
//          / \
//         4   5
// åºåˆ—åŒ–: "1,2,null,null,3,4,null,null,5,null,null"
```

---

## å…«ã€æ€»ç»“ä¸æ‰©å±•

### æ ¸å¿ƒè¦ç‚¹

1. **æ ‘çš„éå†**:
    - DFS: å‰åºã€ä¸­åºã€ååº
    - BFS: å±‚åºéå†
    - é€’å½’ vs è¿­ä»£

2. **å¸¸è§æ“ä½œ**:
    - è®¡ç®—æ·±åº¦/é«˜åº¦
    - æŸ¥æ‰¾èŠ‚ç‚¹
    - è·¯å¾„é—®é¢˜
    - æ ‘çš„å˜æ¢

3. **å®æˆ˜åº”ç”¨**:
    - DOM æ ‘æ“ä½œ
    - æ–‡ä»¶ç³»ç»Ÿ
    - ç»„ä»¶æ ‘
    - è·¯ç”±é…ç½®

### éå†æ–¹å¼çš„é€‰æ‹©

<table>
  <thead>
    <tr>
      <th>åœºæ™¯</th>
      <th>æ¨èéå†</th>
      <th>åŸå› </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>å¤åˆ¶æ ‘</td>
      <td>å‰åº</td>
      <td>å…ˆåˆ›å»ºçˆ¶èŠ‚ç‚¹</td>
    </tr>
    <tr>
      <td>åˆ é™¤æ ‘</td>
      <td>ååº</td>
      <td>å…ˆåˆ é™¤å­èŠ‚ç‚¹</td>
    </tr>
    <tr>
      <td>BST æ’åº</td>
      <td>ä¸­åº</td>
      <td>å¾—åˆ°æœ‰åºåºåˆ—</td>
    </tr>
    <tr>
      <td>å±‚çº§å…³ç³»</td>
      <td>å±‚åº</td>
      <td>é€å±‚å¤„ç†</td>
    </tr>
    <tr>
      <td>æœ€çŸ­è·¯å¾„</td>
      <td>BFS</td>
      <td>å…ˆæ‰¾åˆ°çš„ä¸€å®šæœ€çŸ­</td>
    </tr>
    <tr>
      <td>æ·±åº¦æœç´¢</td>
      <td>DFS</td>
      <td>æ¢ç´¢æ‰€æœ‰å¯èƒ½</td>
    </tr>
  </tbody>
</table>

### å¸¸è§é™·é˜±

1. **ç©ºèŠ‚ç‚¹æ£€æŸ¥**:
```typescript
// âŒ æ²¡æœ‰æ£€æŸ¥ null
function traverse(root: TreeNode) {
  traverse(root.left); // root å¯èƒ½æ˜¯ null
}

// âœ… æ­£ç¡®æ£€æŸ¥
function traverse(root: TreeNode | null) {
  if (!root) return;
  traverse(root.left);
}
```

2. **é€’å½’æ ˆæº¢å‡º**:
```typescript
// æ ‘å¤ªæ·±å¯èƒ½å¯¼è‡´æ ˆæº¢å‡º
// è€ƒè™‘ä½¿ç”¨è¿­ä»£ç‰ˆæœ¬
```

3. **ä¿®æ”¹æ ‘ç»“æ„æ—¶çš„å¼•ç”¨é—®é¢˜**:
```typescript
// âŒ ç›´æ¥ä¿®æ”¹å¯èƒ½å½±å“éå†
function removeNodes(root: TreeNode) {
  traverse(root, node => {
    if (shouldRemove(node)) {
      node.parent.children.remove(node); // å¯èƒ½å¯¼è‡´éå†é”™è¯¯
    }
  });
}

// âœ… å…ˆæ”¶é›†å†åˆ é™¤
function removeNodes(root: TreeNode) {
  const toRemove = [];
  traverse(root, node => {
    if (shouldRemove(node)) {
      toRemove.push(node);
    }
  });
  toRemove.forEach(node => remove(node));
}
```

### è¿›é˜¶å­¦ä¹ 

1. **äºŒå‰æœç´¢æ ‘ (BST)**: ä¸‹ä¸€ç¯‡è¯¦ç»†è®²è§£
2. **å¹³è¡¡æ ‘**: AVLæ ‘ã€çº¢é»‘æ ‘
3. **Bæ ‘/B+æ ‘**: æ•°æ®åº“ç´¢å¼•
4. **å­—å…¸æ ‘ (Trie)**: å­—ç¬¦ä¸²æœç´¢
5. **çº¿æ®µæ ‘**: åŒºé—´æŸ¥è¯¢
6. **æ ‘çŠ¶æ•°ç»„**: å‰ç¼€å’Œä¼˜åŒ–

### æ€§èƒ½ä¼˜åŒ–å»ºè®®

- âœ… å¯¹äºæ·±åº¦å¾ˆå¤§çš„æ ‘,ä½¿ç”¨è¿­ä»£ä»£æ›¿é€’å½’
- âœ… ç¼“å­˜è®¡ç®—ç»“æœ,é¿å…é‡å¤è®¡ç®—
- âœ… ä½¿ç”¨åˆé€‚çš„éå†æ–¹å¼
- âœ… è€ƒè™‘ä½¿ç”¨å¹³è¡¡æ ‘ä¼˜åŒ–æŸ¥æ‰¾
- âœ… å¯¹äºé¢‘ç¹ä¿®æ”¹çš„åœºæ™¯,è€ƒè™‘ä½¿ç”¨å…¶ä»–æ•°æ®ç»“æ„

---

## ä¸‹æœŸé¢„å‘Š

ä¸‹ä¸€ç¯‡æˆ‘ä»¬å°†å­¦ä¹ **äºŒå‰æœç´¢æ ‘ (BST)**,æ¢è®¨:
- BST çš„æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾
- å¹³è¡¡äºŒå‰æ ‘ (AVL)
- çº¢é»‘æ ‘åŸç†
- å®æˆ˜:è‡ªåŠ¨å®Œæˆã€èŒƒå›´æŸ¥è¯¢

---

**ç›¸å…³èµ„æº**:
- [LeetCode æ ‘é¢˜å•](https://leetcode.cn/tag/tree/)
- [å¯è§†åŒ–äºŒå‰æ ‘](https://visualgo.net/en/bst)
- [æœ¬ç³»åˆ—ä»£ç ä»“åº“](https://github.com/yourname/frontend-algorithms)
