
# æ ˆä¸é˜Ÿåˆ—(å®æˆ˜ç¯‡) - çœŸå®åœºæ™¯åº”ç”¨

> åœ¨åŸºç¡€ç¯‡å’Œè¿›é˜¶ç¯‡ä¸­,æˆ‘ä»¬å­¦ä¹ äº†æ ˆå’Œé˜Ÿåˆ—çš„åŸç†ä¸æŠ€å·§ã€‚æœ¬ç¯‡å°†é€šè¿‡ 7 ä¸ªçœŸå®çš„å‰ç«¯åœºæ™¯,å±•ç¤ºå¦‚ä½•åœ¨å®é™…é¡¹ç›®ä¸­åº”ç”¨è¿™äº›æ•°æ®ç»“æ„ã€‚

## ä¸€ã€æµè§ˆå™¨å†å²è®°å½•ç³»ç»Ÿ

### éœ€æ±‚åˆ†æ

å®ç°ä¸€ä¸ªå®Œæ•´çš„æµè§ˆå™¨å†å²è®°å½•ç³»ç»Ÿ,æ”¯æŒ:
- è®¿é—®æ–°é¡µé¢
- åé€€(å¯æŒ‡å®šæ­¥æ•°)
- å‰è¿›(å¯æŒ‡å®šæ­¥æ•°)
- æ¸…é™¤å‰è¿›å†å²
- è·å–å†å²è®°å½•åˆ—è¡¨

### å®Œæ•´å®ç°

```typescript
/**
  * æµè§ˆå™¨å†å²è®°å½•ç®¡ç†å™¨
  */
class BrowserHistory {
  private backStack: string[] = [];      // åé€€æ ˆ
  private forwardStack: string[] = [];   // å‰è¿›æ ˆ
  private currentPage: string;           // å½“å‰é¡µé¢
  private maxHistory: number;            // æœ€å¤§å†å²è®°å½•æ•°
  
  constructor(homepage: string, maxHistory: number = 50) {
    this.currentPage = homepage;
    this.maxHistory = maxHistory;
  }
  
  /**
    * è®¿é—®æ–°é¡µé¢
    */
  visit(url: string): void {
    // å°†å½“å‰é¡µé¢åŠ å…¥åé€€æ ˆ
    this.backStack.push(this.currentPage);
    
    // é™åˆ¶å†å²è®°å½•æ•°é‡
    if (this.backStack.length > this.maxHistory) {
      this.backStack.shift();
    }
    
    // æ›´æ–°å½“å‰é¡µé¢
    this.currentPage = url;
    
    // æ¸…ç©ºå‰è¿›æ ˆ(è®¿é—®æ–°é¡µé¢åä¸èƒ½å‰è¿›)
    this.forwardStack = [];
    
    console.log(`ğŸ“„ è®¿é—®: ${url}`);
  }
  
  /**
    * åé€€æŒ‡å®šæ­¥æ•°
    */
  back(steps: number = 1): string {
    let actualSteps = 0;
    
    while (steps > 0 && this.backStack.length > 0) {
      // å°†å½“å‰é¡µé¢åŠ å…¥å‰è¿›æ ˆ
      this.forwardStack.push(this.currentPage);
      
      // ä»åé€€æ ˆå–å‡ºé¡µé¢
      this.currentPage = this.backStack.pop()!;
      
      steps--;
      actualSteps++;
    }
    
    console.log(`â¬…ï¸  åé€€ ${actualSteps} æ­¥: ${this.currentPage}`);
    return this.currentPage;
  }
  
  /**
    * å‰è¿›æŒ‡å®šæ­¥æ•°
    */
  forward(steps: number = 1): string {
    let actualSteps = 0;
    
    while (steps > 0 && this.forwardStack.length > 0) {
      // å°†å½“å‰é¡µé¢åŠ å…¥åé€€æ ˆ
      this.backStack.push(this.currentPage);
      
      // ä»å‰è¿›æ ˆå–å‡ºé¡µé¢
      this.currentPage = this.forwardStack.pop()!;
      
      steps--;
      actualSteps++;
    }
    
    console.log(`â¡ï¸  å‰è¿› ${actualSteps} æ­¥: ${this.currentPage}`);
    return this.currentPage;
  }
  
  /**
    * è·å–å½“å‰é¡µé¢
    */
  getCurrentPage(): string {
    return this.currentPage;
  }
  
  /**
    * è·å–å†å²è®°å½•åˆ—è¡¨
    */
  getHistory(): {
    back: string[];
    current: string;
    forward: string[];
  } {
    return {
      back: [...this.backStack],
      current: this.currentPage,
      forward: [...this.forwardStack].reverse()
    };
  }
  
  /**
    * æ£€æŸ¥æ˜¯å¦å¯ä»¥åé€€
    */
  canGoBack(): boolean {
    return this.backStack.length > 0;
  }
  
  /**
    * æ£€æŸ¥æ˜¯å¦å¯ä»¥å‰è¿›
    */
  canGoForward(): boolean {
    return this.forwardStack.length > 0;
  }
  
  /**
    * æ¸…é™¤æ‰€æœ‰å†å²è®°å½•
    */
  clear(): void {
    this.backStack = [];
    this.forwardStack = [];
    console.log('ğŸ—‘ï¸  å†å²è®°å½•å·²æ¸…é™¤');
  }
  
  /**
    * æ‰“å°å†å²è®°å½•(ç”¨äºè°ƒè¯•)
    */
  printHistory(): void {
    const history = this.getHistory();
    console.log('\nğŸ“š å†å²è®°å½•:');
    console.log('åé€€æ ˆ:', history.back.join(' â†’ '));
    console.log('å½“å‰é¡µ:', history.current);
    console.log('å‰è¿›æ ˆ:', history.forward.join(' â†’ '));
    console.log('');
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const browser = new BrowserHistory("google.com");

browser.visit("youtube.com");
browser.visit("facebook.com");
browser.visit("twitter.com");
browser.printHistory();
// åé€€æ ˆ: google.com â†’ youtube.com â†’ facebook.com
// å½“å‰é¡µ: twitter.com
// å‰è¿›æ ˆ: 

browser.back(2);
browser.printHistory();
// åé€€æ ˆ: google.com
// å½“å‰é¡µ: youtube.com
// å‰è¿›æ ˆ: facebook.com â†’ twitter.com

browser.forward(1);
browser.printHistory();
// åé€€æ ˆ: google.com â†’ youtube.com
// å½“å‰é¡µ: facebook.com
// å‰è¿›æ ˆ: twitter.com

browser.visit("instagram.com"); // è®¿é—®æ–°é¡µé¢,æ¸…ç©ºå‰è¿›æ ˆ
browser.printHistory();
// åé€€æ ˆ: google.com â†’ youtube.com â†’ facebook.com
// å½“å‰é¡µ: instagram.com
// å‰è¿›æ ˆ: 
```

### React é›†æˆç¤ºä¾‹

```typescript
/**
  * React Hook å°è£…
  */
import { useState, useCallback } from 'react';

function useBrowserHistory(initialUrl: string) {
  const [history] = useState(() => new BrowserHistory(initialUrl));
  const [, forceUpdate] = useState({});
  
  const visit = useCallback((url: string) => {
    history.visit(url);
    forceUpdate({});
  }, [history]);
  
  const back = useCallback((steps?: number) => {
    history.back(steps);
    forceUpdate({});
  }, [history]);
  
  const forward = useCallback((steps?: number) => {
    history.forward(steps);
    forceUpdate({});
  }, [history]);
  
  return {
    currentPage: history.getCurrentPage(),
    canGoBack: history.canGoBack(),
    canGoForward: history.canGoForward(),
    visit,
    back,
    forward,
    getHistory: () => history.getHistory()
  };
}

// ç»„ä»¶ä¸­ä½¿ç”¨
function BrowserDemo() {
  const { currentPage, canGoBack, canGoForward, visit, back, forward } = 
    useBrowserHistory('google.com');
  
  return (
    <div>
      <div>å½“å‰é¡µé¢: {currentPage}</div>
      <button onClick={() => back()} disabled={!canGoBack}>åé€€</button>
      <button onClick={() => forward()} disabled={!canGoForward}>å‰è¿›</button>
      <button onClick={() => visit('youtube.com')}>è®¿é—® YouTube</button>
    </div>
  );
}
```

---

## äºŒã€æ’¤é”€é‡åšç³»ç»Ÿ

### éœ€æ±‚åˆ†æ

å®ç°ä¸€ä¸ªé€šç”¨çš„æ’¤é”€é‡åšç³»ç»Ÿ,æ”¯æŒ:
- è®°å½•æ“ä½œå†å²
- æ’¤é”€æ“ä½œ
- é‡åšæ“ä½œ
- æ‰¹é‡æ“ä½œ
- æ“ä½œåˆå¹¶
- å†å²è®°å½•é™åˆ¶

### å®Œæ•´å®ç°

```typescript
/**
  * æ“ä½œæ¥å£
  */
interface Action<T = any> {
  type: string;           // æ“ä½œç±»å‹
  execute: () => void;    // æ‰§è¡Œæ“ä½œ
  undo: () => void;       // æ’¤é”€æ“ä½œ
  data?: T;               // æ“ä½œæ•°æ®
  timestamp: number;      // æ—¶é—´æˆ³
}

/**
  * æ’¤é”€é‡åšç®¡ç†å™¨
  */
class UndoRedoManager<T = any> {
  private undoStack: Action<T>[] = [];
  private redoStack: Action<T>[] = [];
  private maxSize: number;
  private isExecuting: boolean = false;
  
  constructor(maxSize: number = 100) {
    this.maxSize = maxSize;
  }
  
  /**
    * æ‰§è¡Œæ–°æ“ä½œ
    */
  execute(action: Action<T>): void {
    if (this.isExecuting) return;
    
    this.isExecuting = true;
    
    try {
      // æ‰§è¡Œæ“ä½œ
      action.execute();
      
      // æ·»åŠ åˆ°æ’¤é”€æ ˆ
      this.undoStack.push({
        ...action,
        timestamp: Date.now()
      });
      
      // æ¸…ç©ºé‡åšæ ˆ
      this.redoStack = [];
      
      // é™åˆ¶æ ˆå¤§å°
      if (this.undoStack.length > this.maxSize) {
        this.undoStack.shift();
      }
      
      console.log(`âœ… æ‰§è¡Œ: ${action.type}`);
    } finally {
      this.isExecuting = false;
    }
  }
  
  /**
    * æ’¤é”€æ“ä½œ
    */
  undo(): boolean {
    if (this.undoStack.length === 0) {
      console.log('âš ï¸  æ²¡æœ‰å¯æ’¤é”€çš„æ“ä½œ');
      return false;
    }
    
    this.isExecuting = true;
    
    try {
      const action = this.undoStack.pop()!;
      action.undo();
      this.redoStack.push(action);
      
      console.log(`â†©ï¸  æ’¤é”€: ${action.type}`);
      return true;
    } finally {
      this.isExecuting = false;
    }
  }
  
  /**
    * é‡åšæ“ä½œ
    */
  redo(): boolean {
    if (this.redoStack.length === 0) {
      console.log('âš ï¸  æ²¡æœ‰å¯é‡åšçš„æ“ä½œ');
      return false;
    }
    
    this.isExecuting = true;
    
    try {
      const action = this.redoStack.pop()!;
      action.execute();
      this.undoStack.push(action);
      
      console.log(`â†ªï¸  é‡åš: ${action.type}`);
      return true;
    } finally {
      this.isExecuting = false;
    }
  }
  
  /**
    * æ‰¹é‡æ’¤é”€
    */
  undoMultiple(count: number): number {
    let undone = 0;
    while (count > 0 && this.undo()) {
      undone++;
      count--;
    }
    return undone;
  }
  
  /**
    * æ‰¹é‡é‡åš
    */
  redoMultiple(count: number): number {
    let redone = 0;
    while (count > 0 && this.redo()) {
      redone++;
      count--;
    }
    return redone;
  }
  
  /**
    * æ¸…é™¤å†å²è®°å½•
    */
  clear(): void {
    this.undoStack = [];
    this.redoStack = [];
    console.log('ğŸ—‘ï¸  å†å²è®°å½•å·²æ¸…é™¤');
  }
  
  /**
    * è·å–å†å²è®°å½•
    */
  getHistory(): {
    undoCount: number;
    redoCount: number;
    undoList: string[];
    redoList: string[];
  } {
    return {
      undoCount: this.undoStack.length,
      redoCount: this.redoStack.length,
      undoList: this.undoStack.map(a => a.type),
      redoList: this.redoStack.map(a => a.type)
    };
  }
  
  /**
    * æ£€æŸ¥æ˜¯å¦å¯ä»¥æ’¤é”€
    */
  canUndo(): boolean {
    return this.undoStack.length > 0;
  }
  
  /**
    * æ£€æŸ¥æ˜¯å¦å¯ä»¥é‡åš
    */
  canRedo(): boolean {
    return this.redoStack.length > 0;
  }
}

// ä½¿ç”¨ç¤ºä¾‹:å¯Œæ–‡æœ¬ç¼–è¾‘å™¨
interface TextState {
  content: string;
  cursorPosition: number;
}

class TextEditor {
  private content: string = '';
  private undoRedo: UndoRedoManager<TextState>;
  
  constructor() {
    this.undoRedo = new UndoRedoManager<TextState>();
  }
  
  /**
    * æ’å…¥æ–‡æœ¬
    */
  insertText(text: string, position: number): void {
    const oldContent = this.content;
    const newContent = 
      oldContent.slice(0, position) + text + oldContent.slice(position);
    
    this.undoRedo.execute({
      type: `æ’å…¥æ–‡æœ¬: "${text}"`,
      execute: () => {
        this.content = newContent;
      },
      undo: () => {
        this.content = oldContent;
      },
      data: { content: newContent, cursorPosition: position + text.length },
      timestamp: Date.now()
    });
  }
  
  /**
    * åˆ é™¤æ–‡æœ¬
    */
  deleteText(start: number, end: number): void {
    const oldContent = this.content;
    const deletedText = oldContent.slice(start, end);
    const newContent = oldContent.slice(0, start) + oldContent.slice(end);
    
    this.undoRedo.execute({
      type: `åˆ é™¤æ–‡æœ¬: "${deletedText}"`,
      execute: () => {
        this.content = newContent;
      },
      undo: () => {
        this.content = oldContent;
      },
      data: { content: newContent, cursorPosition: start },
      timestamp: Date.now()
    });
  }
  
  /**
    * æ›¿æ¢æ–‡æœ¬
    */
  replaceText(start: number, end: number, newText: string): void {
    const oldContent = this.content;
    const replacedText = oldContent.slice(start, end);
    const newContent = 
      oldContent.slice(0, start) + newText + oldContent.slice(end);
    
    this.undoRedo.execute({
      type: `æ›¿æ¢æ–‡æœ¬: "${replacedText}" â†’ "${newText}"`,
      execute: () => {
        this.content = newContent;
      },
      undo: () => {
        this.content = oldContent;
      },
      data: { content: newContent, cursorPosition: start + newText.length },
      timestamp: Date.now()
    });
  }
  
  /**
    * æ’¤é”€
    */
  undo(): void {
    this.undoRedo.undo();
  }
  
  /**
    * é‡åš
    */
  redo(): void {
    this.undoRedo.redo();
  }
  
  /**
    * è·å–å†…å®¹
    */
  getContent(): string {
    return this.content;
  }
  
  /**
    * æ‰“å°å†å²
    */
  printHistory(): void {
    const history = this.undoRedo.getHistory();
    console.log('\nğŸ“ ç¼–è¾‘å†å²:');
    console.log('å¯æ’¤é”€:', history.undoList.join(' â†’ '));
    console.log('å¯é‡åš:', history.redoList.join(' â†’ '));
    console.log('å½“å‰å†…å®¹:', this.content);
    console.log('');
  }
}

// æµ‹è¯•
const editor = new TextEditor();

editor.insertText('Hello', 0);
editor.insertText(' World', 5);
editor.insertText('!', 11);
editor.printHistory();
// å½“å‰å†…å®¹: Hello World!

editor.undo();
editor.printHistory();
// å½“å‰å†…å®¹: Hello World

editor.undo();
editor.printHistory();
// å½“å‰å†…å®¹: Hello

editor.redo();
editor.printHistory();
// å½“å‰å†…å®¹: Hello World

editor.replaceText(6, 11, 'TypeScript');
editor.printHistory();
// å½“å‰å†…å®¹: Hello TypeScript
```

### å¿«æ·é”®ç»‘å®š

```typescript
/**
  * ç»‘å®šé”®ç›˜å¿«æ·é”®
  */
function setupUndoRedoShortcuts(editor: TextEditor) {
  document.addEventListener('keydown', (e) => {
    // Ctrl+Z / Cmd+Z: æ’¤é”€
    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
      e.preventDefault();
      editor.undo();
    }
    
    // Ctrl+Shift+Z / Cmd+Shift+Z: é‡åš
    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && e.shiftKey) {
      e.preventDefault();
      editor.redo();
    }
    
    // Ctrl+Y / Cmd+Y: é‡åš(Windows é£æ ¼)
    if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
      e.preventDefault();
      editor.redo();
    }
  });
}
```

---

## ä¸‰ã€å¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ—

### éœ€æ±‚åˆ†æ

å®ç°ä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ—,æ”¯æŒ:
- æ§åˆ¶å¹¶å‘æ•°
- ä»»åŠ¡ä¼˜å…ˆçº§
- ä»»åŠ¡å–æ¶ˆ
- é”™è¯¯å¤„ç†
- è¿›åº¦è¿½è¸ª

### å®Œæ•´å®ç°

```typescript
/**
  * ä»»åŠ¡æ¥å£
  */
interface Task<T = any> {
  id: string;
  fn: () => Promise<T>;
  priority?: number;      // ä¼˜å…ˆçº§(æ•°å­—è¶Šå¤§è¶Šä¼˜å…ˆ)
  timeout?: number;       // è¶…æ—¶æ—¶é—´(æ¯«ç§’)
  retries?: number;       // é‡è¯•æ¬¡æ•°
}

/**
  * ä»»åŠ¡ç»“æœ
  */
interface TaskResult<T = any> {
  id: string;
  status: 'success' | 'error' | 'timeout' | 'cancelled';
  data?: T;
  error?: Error;
  duration: number;
}

/**
  * å¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ—
  */
class AsyncTaskQueue<T = any> {
  private queue: Task<T>[] = [];
  private running: Map<string, Promise<any>> = new Map();
  private results: Map<string, TaskResult<T>> = new Map();
  private maxConcurrent: number;
  private paused: boolean = false;
  
  constructor(maxConcurrent: number = 3) {
    this.maxConcurrent = maxConcurrent;
  }
  
  /**
    * æ·»åŠ ä»»åŠ¡
    */
  async add(task: Task<T>): Promise<TaskResult<T>> {
    return new Promise((resolve, reject) => {
      const wrappedTask: Task<T> = {
        ...task,
        priority: task.priority || 0,
        fn: async () => {
          const startTime = Date.now();
          
          try {
            // è®¾ç½®è¶…æ—¶
            const timeoutPromise = task.timeout
              ? new Promise<never>((_, reject) =>
                  setTimeout(() => reject(new Error('Task timeout')), task.timeout)
                )
              : null;
            
            // æ‰§è¡Œä»»åŠ¡
            const result = timeoutPromise
              ? await Promise.race([task.fn(), timeoutPromise])
              : await task.fn();
            
            const taskResult: TaskResult<T> = {
              id: task.id,
              status: 'success',
              data: result,
              duration: Date.now() - startTime
            };
            
            this.results.set(task.id, taskResult);
            resolve(taskResult);
            return result;
          } catch (error) {
            const taskResult: TaskResult<T> = {
              id: task.id,
              status: error instanceof Error && error.message === 'Task timeout'
                ? 'timeout'
                : 'error',
              error: error as Error,
              duration: Date.now() - startTime
            };
            
            this.results.set(task.id, taskResult);
            
            // é‡è¯•é€»è¾‘
            if (task.retries && task.retries > 0) {
              console.log(`ğŸ”„ é‡è¯•ä»»åŠ¡ ${task.id}, å‰©ä½™æ¬¡æ•°: ${task.retries}`);
              return this.add({ ...task, retries: task.retries - 1 });
            }
            
            reject(taskResult);
            throw error;
          }
        }
      };
      
      // æŒ‰ä¼˜å…ˆçº§æ’å…¥é˜Ÿåˆ—
      this.insertByPriority(wrappedTask);
      this.run();
    });
  }
  
  /**
    * æŒ‰ä¼˜å…ˆçº§æ’å…¥ä»»åŠ¡
    */
  private insertByPriority(task: Task<T>): void {
    const index = this.queue.findIndex(t => (t.priority || 0) < (task.priority || 0));
    if (index === -1) {
      this.queue.push(task);
    } else {
      this.queue.splice(index, 0, task);
    }
    console.log(`â• æ·»åŠ ä»»åŠ¡ ${task.id} (ä¼˜å…ˆçº§: ${task.priority || 0})`);
  }
  
  /**
    * æ‰§è¡Œé˜Ÿåˆ—ä¸­çš„ä»»åŠ¡
    */
  private async run(): Promise<void> {
    if (this.paused) return;
    
    while (
      this.running.size < this.maxConcurrent &&
      this.queue.length > 0
    ) {
      const task = this.queue.shift()!;
      
      console.log(`â–¶ï¸  å¼€å§‹æ‰§è¡Œä»»åŠ¡ ${task.id}`);
      
      const promise = task.fn().finally(() => {
        this.running.delete(task.id);
        console.log(`âœ… å®Œæˆä»»åŠ¡ ${task.id}`);
        this.run(); // ç»§ç»­æ‰§è¡Œä¸‹ä¸€ä¸ªä»»åŠ¡
      });
      
      this.running.set(task.id, promise);
    }
  }
  
  /**
    * å–æ¶ˆä»»åŠ¡
    */
  cancel(taskId: string): boolean {
    // ä»é˜Ÿåˆ—ä¸­ç§»é™¤
    const index = this.queue.findIndex(t => t.id === taskId);
    if (index !== -1) {
      this.queue.splice(index, 1);
      
      this.results.set(taskId, {
        id: taskId,
        status: 'cancelled',
        duration: 0
      });
      
      console.log(`âŒ å–æ¶ˆä»»åŠ¡ ${taskId}`);
      return true;
    }
    
    return false;
  }
  
  /**
    * æš‚åœé˜Ÿåˆ—
    */
  pause(): void {
    this.paused = true;
    console.log('â¸ï¸  é˜Ÿåˆ—å·²æš‚åœ');
  }
  
  /**
    * æ¢å¤é˜Ÿåˆ—
    */
  resume(): void {
    this.paused = false;
    console.log('â–¶ï¸  é˜Ÿåˆ—å·²æ¢å¤');
    this.run();
  }
  
  /**
    * æ¸…ç©ºé˜Ÿåˆ—
    */
  clear(): void {
    this.queue = [];
    console.log('ğŸ—‘ï¸  é˜Ÿåˆ—å·²æ¸…ç©º');
  }
  
  /**
    * ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    */
  async waitAll(): Promise<TaskResult<T>[]> {
    while (this.queue.length > 0 || this.running.size > 0) {
      await Promise.all(this.running.values());
      await new Promise(resolve => setTimeout(resolve, 10));
    }
    return Array.from(this.results.values());
  }
  
  /**
    * è·å–é˜Ÿåˆ—çŠ¶æ€
    */
  getStatus(): {
    pending: number;
    running: number;
    completed: number;
    failed: number;
  } {
    const results = Array.from(this.results.values());
    return {
      pending: this.queue.length,
      running: this.running.size,
      completed: results.filter(r => r.status === 'success').length,
      failed: results.filter(r => r.status === 'error' || r.status === 'timeout').length
    };
  }
  
  /**
    * è·å–ä»»åŠ¡ç»“æœ
    */
  getResult(taskId: string): TaskResult<T> | undefined {
    return this.results.get(taskId);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const taskQueue = new AsyncTaskQueue(2); // æœ€å¤šåŒæ—¶æ‰§è¡Œ2ä¸ªä»»åŠ¡

// æ¨¡æ‹Ÿ API è¯·æ±‚
const fetchData = (id: number, delay: number): Promise<string> => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(`æ•°æ® ${id}`);
    }, delay);
  });
};

// æ·»åŠ ä»»åŠ¡
taskQueue.add({
  id: 'task-1',
  fn: () => fetchData(1, 2000),
  priority: 1
});

taskQueue.add({
  id: 'task-2',
  fn: () => fetchData(2, 1000),
  priority: 2 // é«˜ä¼˜å…ˆçº§
});

taskQueue.add({
  id: 'task-3',
  fn: () => fetchData(3, 1500),
  timeout: 1000, // 1ç§’è¶…æ—¶
  retries: 2     // é‡è¯•2æ¬¡
});

taskQueue.add({
  id: 'task-4',
  fn: () => fetchData(4, 500)
});

// ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
taskQueue.waitAll().then(results => {
  console.log('\nğŸ“Š ä»»åŠ¡å®Œæˆç»Ÿè®¡:');
  console.log('æ€»ä»»åŠ¡æ•°:', results.length);
  console.log('æˆåŠŸ:', results.filter(r => r.status === 'success').length);
  console.log('å¤±è´¥:', results.filter(r => r.status === 'error').length);
  console.log('è¶…æ—¶:', results.filter(r => r.status === 'timeout').length);
});
```

### å®é™…åº”ç”¨åœºæ™¯

```typescript
/**
  * å›¾ç‰‡æ‰¹é‡ä¸Šä¼ 
  */
async function uploadImages(files: File[]) {
  const uploadQueue = new AsyncTaskQueue(3); // æœ€å¤šåŒæ—¶ä¸Šä¼ 3å¼ 
  
  const tasks = files.map((file, index) => ({
    id: `upload-${index}`,
    fn: async () => {
      const formData = new FormData();
      formData.append('file', file);
      
      const response = await fetch('/api/upload', {
        method: 'POST',
        body: formData
      });
      
      return response.json();
    },
    timeout: 30000, // 30ç§’è¶…æ—¶
    retries: 2      // å¤±è´¥é‡è¯•2æ¬¡
  }));
  
  // æ·»åŠ æ‰€æœ‰ä»»åŠ¡
  const promises = tasks.map(task => uploadQueue.add(task));
  
  // ç­‰å¾…æ‰€æœ‰ä¸Šä¼ å®Œæˆ
  const results = await Promise.allSettled(promises);
  
  return results;
}
```

---

## å››ã€LRU ç¼“å­˜å®ç°

### éœ€æ±‚åˆ†æ

å®ç°ä¸€ä¸ª LRU (Least Recently Used) ç¼“å­˜,æ”¯æŒ:
- O(1) çš„è¯»å†™æ“ä½œ
- è‡ªåŠ¨æ·˜æ±°æœ€ä¹…æœªä½¿ç”¨çš„æ•°æ®
- å®¹é‡é™åˆ¶
- è¿‡æœŸæ—¶é—´

### å®Œæ•´å®ç°

```typescript
/**
  * ç¼“å­˜é¡¹
  */
interface CacheItem<T> {
  key: string;
  value: T;
  expireTime?: number; // è¿‡æœŸæ—¶é—´æˆ³
}

/**
  * LRU ç¼“å­˜
  */
class LRUCache<T = any> {
  private capacity: number;
  private cache: Map<string, T>;
  private expireMap: Map<string, number>;
  
  constructor(capacity: number) {
    this.capacity = capacity;
    this.cache = new Map();
    this.expireMap = new Map();
  }
  
  /**
    * è·å–å€¼
    */
  get(key: string): T | undefined {
    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if (this.isExpired(key)) {
      this.delete(key);
      return undefined;
    }
    
    if (!this.cache.has(key)) {
      return undefined;
    }
    
    // æ›´æ–°è®¿é—®é¡ºåº(åˆ é™¤åé‡æ–°æ’å…¥)
    const value = this.cache.get(key)!;
    this.cache.delete(key);
    this.cache.set(key, value);
    
    console.log(`ğŸ” è¯»å–ç¼“å­˜: ${key}`);
    return value;
  }
  
  /**
    * è®¾ç½®å€¼
    */
  set(key: string, value: T, ttl?: number): void {
    // å¦‚æœé”®å·²å­˜åœ¨,å…ˆåˆ é™¤
    if (this.cache.has(key)) {
      this.cache.delete(key);
    }
    
    // æ’å…¥æ–°å€¼
    this.cache.set(key, value);
    
    // è®¾ç½®è¿‡æœŸæ—¶é—´
    if (ttl) {
      this.expireMap.set(key, Date.now() + ttl);
    }
    
    // å¦‚æœè¶…å‡ºå®¹é‡,åˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„(Map çš„ç¬¬ä¸€ä¸ªå…ƒç´ )
    if (this.cache.size > this.capacity) {
      const firstKey = this.cache.keys().next().value;
      this.delete(firstKey);
      console.log(`ğŸ—‘ï¸  æ·˜æ±°ç¼“å­˜: ${firstKey}`);
    }
    
    console.log(`ğŸ’¾ å†™å…¥ç¼“å­˜: ${key}`);
  }
  
  /**
    * åˆ é™¤é”®
    */
  delete(key: string): boolean {
    this.expireMap.delete(key);
    return this.cache.delete(key);
  }
  
  /**
    * æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    */
  private isExpired(key: string): boolean {
    const expireTime = this.expireMap.get(key);
    if (!expireTime) return false;
    
    if (Date.now() > expireTime) {
      return true;
    }
    
    return false;
  }
  
  /**
    * æ¸…ç†è¿‡æœŸç¼“å­˜
    */
  cleanup(): number {
    let cleaned = 0;
    for (const [key, expireTime] of this.expireMap.entries()) {
      if (Date.now() > expireTime) {
        this.delete(key);
        cleaned++;
      }
    }
    
    if (cleaned > 0) {
      console.log(`ğŸ§¹ æ¸…ç†äº† ${cleaned} ä¸ªè¿‡æœŸç¼“å­˜`);
    }
    
    return cleaned;
  }
  
  /**
    * æ¸…ç©ºç¼“å­˜
    */
  clear(): void {
    this.cache.clear();
    this.expireMap.clear();
    console.log('ğŸ—‘ï¸  ç¼“å­˜å·²æ¸…ç©º');
  }
  
  /**
    * è·å–ç¼“å­˜å¤§å°
    */
  size(): number {
    return this.cache.size;
  }
  
  /**
    * æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨
    */
  has(key: string): boolean {
    if (this.isExpired(key)) {
      this.delete(key);
      return false;
    }
    return this.cache.has(key);
  }
  
  /**
    * è·å–æ‰€æœ‰é”®
    */
  keys(): string[] {
    // æ¸…ç†è¿‡æœŸç¼“å­˜
    this.cleanup();
    return Array.from(this.cache.keys());
  }
  
  /**
    * æ‰“å°ç¼“å­˜çŠ¶æ€
    */
  print(): void {
    console.log('\nğŸ“¦ ç¼“å­˜å†…å®¹:');
    console.log('å®¹é‡:', `${this.cache.size}/${this.capacity}`);
    console.log('é”®å€¼å¯¹:', Array.from(this.cache.entries()));
    console.log('');
  }
}

// æµ‹è¯•
const cache = new LRUCache<string>(3);

cache.set('a', 'æ•°æ®A');
cache.set('b', 'æ•°æ®B');
cache.set('c', 'æ•°æ®C');
cache.print();
// å®¹é‡: 3/3

console.log(cache.get('a')); // è®¿é—® a,æ›´æ–°é¡ºåº
cache.set('d', 'æ•°æ®D');     // æ·˜æ±° b
cache.print();
// å®¹é‡: 3/3, é”®: a, c, d

// æµ‹è¯•è¿‡æœŸæ—¶é—´
cache.set('e', 'æ•°æ®E', 1000); // 1ç§’åè¿‡æœŸ
setTimeout(() => {
  console.log(cache.get('e')); // undefined (å·²è¿‡æœŸ)
}, 1500);
```

### å®é™…åº”ç”¨:API å“åº”ç¼“å­˜

```typescript
/**
  * API ç¼“å­˜è£…é¥°å™¨
  */
class APICache {
  private cache: LRUCache<any>;
  
  constructor(capacity: number = 100) {
    this.cache = new LRUCache(capacity);
    
    // æ¯åˆ†é’Ÿæ¸…ç†ä¸€æ¬¡è¿‡æœŸç¼“å­˜
    setInterval(() => this.cache.cleanup(), 60000);
  }
  
  /**
    * åŒ…è£… fetch è¯·æ±‚
    */
  async fetch(url: string, options?: RequestInit, ttl: number = 300000): Promise<any> {
    const cacheKey = this.getCacheKey(url, options);
    
    // å°è¯•ä»ç¼“å­˜è¯»å–
    const cached = this.cache.get(cacheKey);
    if (cached) {
      console.log('âœ… å‘½ä¸­ç¼“å­˜:', url);
      return cached;
    }
    
    // å‘èµ·è¯·æ±‚
    console.log('ğŸŒ å‘èµ·è¯·æ±‚:', url);
    const response = await fetch(url, options);
    const data = await response.json();
    
    // å†™å…¥ç¼“å­˜
    this.cache.set(cacheKey, data, ttl);
    
    return data;
  }
  
  /**
    * ç”Ÿæˆç¼“å­˜é”®
    */
  private getCacheKey(url: string, options?: RequestInit): string {
    return `${url}:${JSON.stringify(options || {})}`;
  }
  
  /**
    * æ¸…é™¤æŒ‡å®š URL çš„ç¼“å­˜
    */
  invalidate(url: string): void {
    const keys = this.cache.keys().filter(key => key.startsWith(url));
    keys.forEach(key => this.cache.delete(key));
    console.log(`ğŸ—‘ï¸  æ¸…é™¤äº† ${keys.length} ä¸ªç›¸å…³ç¼“å­˜`);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const apiCache = new APICache(50);

// ç¬¬ä¸€æ¬¡è¯·æ±‚(å‘èµ·ç½‘ç»œè¯·æ±‚)
await apiCache.fetch('/api/users', {}, 60000); // ç¼“å­˜1åˆ†é’Ÿ

// ç¬¬äºŒæ¬¡è¯·æ±‚(ä»ç¼“å­˜è¯»å–)
await apiCache.fetch('/api/users', {}, 60000);

// æ¸…é™¤ç¼“å­˜
apiCache.invalidate('/api/users');
```

---

## äº”ã€å‡½æ•°è°ƒç”¨æ ˆè¿½è¸ªå™¨

### éœ€æ±‚åˆ†æ

å®ç°ä¸€ä¸ªå‡½æ•°è°ƒç”¨æ ˆè¿½è¸ªå™¨,ç”¨äº:
- è°ƒè¯•é€’å½’å‡½æ•°
- æ€§èƒ½åˆ†æ
- è°ƒç”¨é“¾å¯è§†åŒ–

### å®Œæ•´å®ç°

```typescript
/**
  * è°ƒç”¨ä¿¡æ¯
  */
interface CallInfo {
  functionName: string;
  args: any[];
  startTime: number;
  endTime?: number;
  result?: any;
  error?: Error;
}

/**
  * å‡½æ•°è°ƒç”¨æ ˆè¿½è¸ªå™¨
  */
class CallStackTracker {
  private stack: CallInfo[] = [];
  private callHistory: CallInfo[] = [];
  private maxDepth: number = 0;
  private enabled: boolean = true;
  
  /**
    * è¿›å…¥å‡½æ•°
    */
  enter(functionName: string, args: any[] = []): void {
    if (!this.enabled) return;
    
    const callInfo: CallInfo = {
      functionName,
      args,
      startTime: performance.now()
    };
    
    this.stack.push(callInfo);
    this.maxDepth = Math.max(this.maxDepth, this.stack.length);
    
    this.printIndented(`â†’ ${functionName}(${this.formatArgs(args)})`);
  }
  
  /**
    * é€€å‡ºå‡½æ•°
    */
  exit(result?: any): void {
    if (!this.enabled) return;
    
    const callInfo = this.stack.pop();
    if (!callInfo) return;
    
    callInfo.endTime = performance.now();
    callInfo.result = result;
    
    const duration = callInfo.endTime - callInfo.startTime;
    this.callHistory.push(callInfo);
    
    this.printIndented(
      `â† ${callInfo.functionName} (${duration.toFixed(2)}ms)`,
      this.stack.length
    );
  }
  
  /**
    * è®°å½•é”™è¯¯
    */
  error(error: Error): void {
    if (!this.enabled) return;
    
    const callInfo = this.stack[this.stack.length - 1];
    if (callInfo) {
      callInfo.error = error;
      callInfo.endTime = performance.now();
    }
    
    this.printIndented(`âŒ ${error.message}`);
  }
  
  /**
    * æ‰“å°ç¼©è¿›çš„æ—¥å¿—
    */
  private printIndented(message: string, depth?: number): void {
    const indent = '  '.repeat(depth ?? this.stack.length);
    console.log(`${indent}${message}`);
  }
  
  /**
    * æ ¼å¼åŒ–å‚æ•°
    */
  private formatArgs(args: any[]): string {
    return args.map(arg => {
      if (typeof arg === 'object') {
        return JSON.stringify(arg);
      }
      return String(arg);
    }).join(', ');
  }
  
  /**
    * è·å–ç»Ÿè®¡ä¿¡æ¯
    */
  getStats(): {
    maxDepth: number;
    totalCalls: number;
    averageDuration: number;
    slowestCalls: CallInfo[];
  } {
    const durations = this.callHistory
      .filter(c => c.endTime)
      .map(c => c.endTime! - c.startTime);
    
    const avgDuration = durations.length > 0
      ? durations.reduce((a, b) => a + b, 0) / durations.length
      : 0;
    
    const slowest = [...this.callHistory]
      .filter(c => c.endTime)
      .sort((a, b) => (b.endTime! - b.startTime) - (a.endTime! - a.startTime))
      .slice(0, 5);
    
    return {
      maxDepth: this.maxDepth,
      totalCalls: this.callHistory.length,
      averageDuration: avgDuration,
      slowestCalls: slowest
    };
  }
  
  /**
    * å¯ç”¨/ç¦ç”¨è¿½è¸ª
    */
  setEnabled(enabled: boolean): void {
    this.enabled = enabled;
  }
  
  /**
    * æ¸…é™¤å†å²
    */
  clear(): void {
    this.stack = [];
    this.callHistory = [];
    this.maxDepth = 0;
  }
}

// ä½¿ç”¨ç¤ºä¾‹:è¿½è¸ªæ–æ³¢é‚£å¥‘å‡½æ•°
const tracker = new CallStackTracker();

function fibonacci(n: number): number {
  tracker.enter('fibonacci', [n]);
  
  if (n <= 1) {
    tracker.exit(n);
    return n;
  }
  
  const result = fibonacci(n - 1) + fibonacci(n - 2);
  tracker.exit(result);
  return result;
}

console.log('\nğŸ” è¿½è¸ª fibonacci(4):\n');
const result = fibonacci(4);
console.log(`\nç»“æœ: ${result}\n`);

const stats = tracker.getStats();
console.log('ğŸ“Š ç»Ÿè®¡ä¿¡æ¯:');
console.log('æœ€å¤§æ·±åº¦:', stats.maxDepth);
console.log('æ€»è°ƒç”¨æ¬¡æ•°:', stats.totalCalls);
console.log('å¹³å‡è€—æ—¶:', stats.averageDuration.toFixed(2), 'ms');

// è¾“å‡º:
// â†’ fibonacci(4)
//   â†’ fibonacci(3)
//     â†’ fibonacci(2)
//       â†’ fibonacci(1)
//       â† fibonacci (0.05ms)
//       â†’ fibonacci(0)
//       â† fibonacci (0.03ms)
//     â† fibonacci (0.15ms)
//     â†’ fibonacci(1)
//     â† fibonacci (0.03ms)
//   â† fibonacci (0.25ms)
//   â†’ fibonacci(2)
//     â†’ fibonacci(1)
//     â† fibonacci (0.03ms)
//     â†’ fibonacci(0)
//     â† fibonacci (0.02ms)
//   â† fibonacci (0.12ms)
// â† fibonacci (0.42ms)
```

### è£…é¥°å™¨ç‰ˆæœ¬

```typescript
/**
  * å‡½æ•°è¿½è¸ªè£…é¥°å™¨
  */
function trace(tracker: CallStackTracker) {
  return function (
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;
    
    descriptor.value = function (...args: any[]) {
      tracker.enter(propertyKey, args);
      
      try {
        const result = originalMethod.apply(this, args);
        
        // å¤„ç† Promise
        if (result instanceof Promise) {
          return result
            .then(value => {
              tracker.exit(value);
              return value;
            })
            .catch(error => {
              tracker.error(error);
              throw error;
            });
        }
        
        tracker.exit(result);
        return result;
      } catch (error) {
        tracker.error(error as Error);
        throw error;
      }
    };
    
    return descriptor;
  };
}

// ä½¿ç”¨è£…é¥°å™¨
class Calculator {
  @trace(tracker)
  factorial(n: number): number {
    if (n <= 1) return 1;
    return n * this.factorial(n - 1);
  }
}
```

---

## å…­ã€è¡¨è¾¾å¼æ±‚å€¼å™¨

### éœ€æ±‚åˆ†æ

å®ç°ä¸€ä¸ªå®Œæ•´çš„è¡¨è¾¾å¼æ±‚å€¼å™¨,æ”¯æŒ:
- å››åˆ™è¿ç®—
- æ‹¬å·
- å˜é‡
- å‡½æ•°è°ƒç”¨

### å®Œæ•´å®ç°

```typescript
/**
  * è¡¨è¾¾å¼æ±‚å€¼å™¨
  */
class ExpressionEvaluator {
  private variables: Map<string, number> = new Map();
  private functions: Map<string, (...args: number[]) => number> = new Map();
  
  constructor() {
    // æ³¨å†Œå†…ç½®å‡½æ•°
    this.registerFunction('abs', Math.abs);
    this.registerFunction('sqrt', Math.sqrt);
    this.registerFunction('pow', Math.pow);
    this.registerFunction('max', Math.max);
    this.registerFunction('min', Math.min);
  }
  
  /**
    * æ³¨å†Œå˜é‡
    */
  setVariable(name: string, value: number): void {
    this.variables.set(name, value);
  }
  
  /**
    * æ³¨å†Œå‡½æ•°
    */
  registerFunction(name: string, fn: (...args: number[]) => number): void {
    this.functions.set(name, fn);
  }
  
  /**
    * æ±‚å€¼
    */
  evaluate(expression: string): number {
    // 1. è¯æ³•åˆ†æ:åˆ†è¯
    const tokens = this.tokenize(expression);
    
    // 2. è¯­æ³•åˆ†æ:ä¸­ç¼€è½¬åç¼€
    const postfix = this.infixToPostfix(tokens);
    
    // 3. è®¡ç®—åç¼€è¡¨è¾¾å¼
    return this.evaluatePostfix(postfix);
  }
  
  /**
    * è¯æ³•åˆ†æ
    */
  private tokenize(expression: string): string[] {
    const tokens: string[] = [];
    let current = '';
    
    for (let i = 0; i < expression.length; i++) {
      const char = expression[i];
      
      if (char === ' ') {
        if (current) {
          tokens.push(current);
          current = '';
        }
      } else if ('+-*/()'.includes(char)) {
        if (current) {
          tokens.push(current);
          current = '';
        }
        tokens.push(char);
      } else {
        current += char;
      }
    }
    
    if (current) {
      tokens.push(current);
    }
    
    return tokens;
  }
  
  /**
    * ä¸­ç¼€è½¬åç¼€
    */
  private infixToPostfix(tokens: string[]): string[] {
    const output: string[] = [];
    const operators: string[] = [];
    const precedence: Record<string, number> = {
      '+': 1, '-': 1,
      '*': 2, '/': 2
    };
    
    for (const token of tokens) {
      if (this.isNumber(token)) {
        output.push(token);
      } else if (this.isVariable(token)) {
        output.push(token);
      } else if (this.isFunction(token)) {
        operators.push(token);
      } else if (token === '(') {
        operators.push(token);
      } else if (token === ')') {
        while (operators.length && operators[operators.length - 1] !== '(') {
          output.push(operators.pop()!);
        }
        operators.pop(); // å¼¹å‡º '('
        
        // å¦‚æœæ ˆé¡¶æ˜¯å‡½æ•°,ä¹Ÿå¼¹å‡º
        if (operators.length && this.isFunction(operators[operators.length - 1])) {
          output.push(operators.pop()!);
        }
      } else if (token in precedence) {
        while (
          operators.length &&
          operators[operators.length - 1] !== '(' &&
          precedence[operators[operators.length - 1]] >= precedence[token]
        ) {
          output.push(operators.pop()!);
        }
        operators.push(token);
      }
    }
    
    while (operators.length) {
      output.push(operators.pop()!);
    }
    
    return output;
  }
  
  /**
    * è®¡ç®—åç¼€è¡¨è¾¾å¼
    */
  private evaluatePostfix(tokens: string[]): number {
    const stack: number[] = [];
    
    for (const token of tokens) {
      if (this.isNumber(token)) {
        stack.push(parseFloat(token));
      } else if (this.isVariable(token)) {
        const value = this.variables.get(token);
        if (value === undefined) {
          throw new Error(`æœªå®šä¹‰çš„å˜é‡: ${token}`);
        }
        stack.push(value);
      } else if (this.isFunction(token)) {
        const fn = this.functions.get(token);
        if (!fn) {
          throw new Error(`æœªå®šä¹‰çš„å‡½æ•°: ${token}`);
        }
        
        // å‡½æ•°å‚æ•°ä¸ªæ•°(ç®€åŒ–å¤„ç†,å‡è®¾éƒ½æ˜¯2ä¸ªå‚æ•°)
        const b = stack.pop()!;
        const a = stack.pop()!;
        stack.push(fn(a, b));
      } else {
        const b = stack.pop()!;
        const a = stack.pop()!;
        
        switch (token) {
          case '+': stack.push(a + b); break;
          case '-': stack.push(a - b); break;
          case '*': stack.push(a * b); break;
          case '/': stack.push(a / b); break;
        }
      }
    }
    
    return stack[0];
  }
  
  /**
    * åˆ¤æ–­æ˜¯å¦ä¸ºæ•°å­—
    */
  private isNumber(token: string): boolean {
    return !isNaN(parseFloat(token));
  }
  
  /**
    * åˆ¤æ–­æ˜¯å¦ä¸ºå˜é‡
    */
  private isVariable(token: string): boolean {
    return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(token) && !this.functions.has(token);
  }
  
  /**
    * åˆ¤æ–­æ˜¯å¦ä¸ºå‡½æ•°
    */
  private isFunction(token: string): boolean {
    return this.functions.has(token);
  }
}

// æµ‹è¯•
const evaluator = new ExpressionEvaluator();

console.log(evaluator.evaluate('3 + 5 * 2'));           // 13
console.log(evaluator.evaluate('(1 + 2) * 3'));         // 9
console.log(evaluator.evaluate('10 + 2 * 6'));          // 22

// ä½¿ç”¨å˜é‡
evaluator.setVariable('x', 10);
evaluator.setVariable('y', 5);
console.log(evaluator.evaluate('x + y * 2'));           // 20

// ä½¿ç”¨å‡½æ•°
console.log(evaluator.evaluate('max(3, 5)'));           // 5
console.log(evaluator.evaluate('pow(2, 3)'));           // 8
console.log(evaluator.evaluate('sqrt(16) + abs(-5)'));  // 9
```

---

## ä¸ƒã€æ€§èƒ½å¯¹æ¯”ä¸æ€»ç»“

### æ€§èƒ½æµ‹è¯•

```typescript
/**
  * æ€§èƒ½æµ‹è¯•å·¥å…·
  */
function benchmark(name: string, fn: () => void, iterations: number = 10000) {
  const start = performance.now();
  
  for (let i = 0; i < iterations; i++) {
    fn();
  }
  
  const end = performance.now();
  const duration = end - start;
  const avgTime = duration / iterations;
  
  console.log(`\nğŸ“Š ${name}`);
  console.log(`æ€»è€—æ—¶: ${duration.toFixed(2)}ms`);
  console.log(`å¹³å‡è€—æ—¶: ${avgTime.toFixed(4)}ms`);
  console.log(`ååé‡: ${(iterations / duration * 1000).toFixed(0)} ops/s`);
}

// æµ‹è¯•æ•°ç»„é˜Ÿåˆ— vs å¾ªç¯é˜Ÿåˆ—
console.log('=== é˜Ÿåˆ—æ€§èƒ½å¯¹æ¯” ===');

benchmark('æ•°ç»„é˜Ÿåˆ—', () => {
  const queue: number[] = [];
  for (let i = 0; i < 100; i++) {
    queue.push(i);
    queue.shift();
  }
});

benchmark('å¾ªç¯é˜Ÿåˆ—', () => {
  const queue = new CircularQueue<number>(100);
  for (let i = 0; i < 100; i++) {
    queue.enqueue(i);
    queue.dequeue();
  }
});

// è¾“å‡ºç¤ºä¾‹:
// ğŸ“Š æ•°ç»„é˜Ÿåˆ—
// æ€»è€—æ—¶: 1250.50ms
// å¹³å‡è€—æ—¶: 0.1251ms
// ååé‡: 7997 ops/s
//
// ğŸ“Š å¾ªç¯é˜Ÿåˆ—
// æ€»è€—æ—¶: 85.20ms
// å¹³å‡è€—æ—¶: 0.0085ms
// ååé‡: 117371 ops/s
```

### æœ€ä½³å®è·µæ€»ç»“

| åœºæ™¯ | æ¨èæ–¹æ¡ˆ | åŸå›  |
|------|---------|------|
| æµè§ˆå™¨å†å² | åŒæ ˆ | æ”¯æŒå‰è¿›åé€€ |
| æ’¤é”€é‡åš | åŒæ ˆ + æ—¶é—´æˆ³ | éœ€è¦è®°å½•æ“ä½œå†å² |
| å¼‚æ­¥ä»»åŠ¡ | ä¼˜å…ˆé˜Ÿåˆ— + å¹¶å‘æ§åˆ¶ | æ”¯æŒä¼˜å…ˆçº§å’Œé™æµ |
| API ç¼“å­˜ | LRU + è¿‡æœŸæ—¶é—´ | è‡ªåŠ¨æ·˜æ±° + æ—¶æ•ˆæ€§ |
| è¡¨è¾¾å¼æ±‚å€¼ | åŒæ ˆ(è¿ç®—ç¬¦+æ“ä½œæ•°) | ç»å…¸ç®—æ³• |
| å‡½æ•°è¿½è¸ª | æ ˆ + æ€§èƒ½è®¡æ—¶ | è®°å½•è°ƒç”¨é“¾ |
| é«˜é¢‘å‡ºé˜Ÿ | å¾ªç¯é˜Ÿåˆ— | O(1) æ€§èƒ½ |

### å¸¸è§é™·é˜±

1. **å†…å­˜æ³„æ¼**
```typescript
// âŒ é˜Ÿåˆ—ä¸æ–­å¢é•¿
const queue: any[] = [];
setInterval(() => {
  queue.push(data);
  // å¿˜è®°å‡ºé˜Ÿ
}, 1000);

// âœ… é™åˆ¶é˜Ÿåˆ—å¤§å°
if (queue.length > MAX_SIZE) {
  queue.shift();
}
```

2. **æ ˆæº¢å‡º**
```typescript
// âŒ é€’å½’æ·±åº¦è¿‡å¤§
function deepRecursion(n: number): number {
  if (n === 0) return 0;
  return deepRecursion(n - 1); // å¯èƒ½æ ˆæº¢å‡º
}

// âœ… æ”¹ç”¨è¿­ä»£
function iterative(n: number): number {
  let result = 0;
  while (n > 0) {
    result += n--;
  }
  return result;
}
```

3. **å¹¶å‘é—®é¢˜**
```typescript
// âŒ æ²¡æœ‰å¹¶å‘æ§åˆ¶
const promises = urls.map(url => fetch(url)); // åŒæ—¶å‘èµ·æ‰€æœ‰è¯·æ±‚

// âœ… ä½¿ç”¨ä»»åŠ¡é˜Ÿåˆ—
const queue = new AsyncTaskQueue(5);
const promises = urls.map(url => 
  queue.add({ id: url, fn: () => fetch(url) })
);
```

---

## å…«ã€æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **æµè§ˆå™¨å†å²**: åŒæ ˆå®ç°å‰è¿›åé€€
2. **æ’¤é”€é‡åš**: æ ˆ + å‘½ä»¤æ¨¡å¼
3. **å¼‚æ­¥ä»»åŠ¡**: é˜Ÿåˆ— + å¹¶å‘æ§åˆ¶ + ä¼˜å…ˆçº§
4. **LRU ç¼“å­˜**: Map + è®¿é—®é¡ºåº + è¿‡æœŸæ—¶é—´
5. **è¡¨è¾¾å¼æ±‚å€¼**: åŒæ ˆ + è°ƒåº¦åœºç®—æ³•
6. **å‡½æ•°è¿½è¸ª**: æ ˆ + æ€§èƒ½è®¡æ—¶

### æ€§èƒ½ä¼˜åŒ–å»ºè®®

- âœ… ä½¿ç”¨**å¾ªç¯é˜Ÿåˆ—**ä»£æ›¿æ•°ç»„é˜Ÿåˆ—
- âœ… ä¸º LRU ç¼“å­˜è®¾ç½®**åˆç†å®¹é‡**
- âœ… å¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ—è¦**é™åˆ¶å¹¶å‘æ•°**
- âœ… å®šæœŸ**æ¸…ç†è¿‡æœŸæ•°æ®**
- âœ… ä½¿ç”¨**å¯¹è±¡æ± **å‡å°‘ GC å‹åŠ›

### å®é™…åº”ç”¨åœºæ™¯

- ğŸŒ æµè§ˆå™¨:å†å²è®°å½•ã€æ ‡ç­¾é¡µç®¡ç†
- âœï¸ ç¼–è¾‘å™¨:æ’¤é”€é‡åšã€è¯­æ³•é«˜äº®
- ğŸ¨ è®¾è®¡å·¥å…·:å›¾å±‚ç®¡ç†ã€æ“ä½œå†å²
- ğŸ“¡ ç½‘ç»œ:è¯·æ±‚é˜Ÿåˆ—ã€ç¼“å­˜ç®¡ç†
- ğŸ® æ¸¸æˆ:çŠ¶æ€å›æº¯ã€åŠ¨ç”»é˜Ÿåˆ—

---

## ç³»åˆ—å›é¡¾

æœ¬ç³»åˆ—æˆ‘ä»¬å­¦ä¹ äº†æ ˆä¸é˜Ÿåˆ—çš„:

**åŸºç¡€ç¯‡**:
- æ ˆå’Œé˜Ÿåˆ—çš„åŸºæœ¬æ¦‚å¿µ
- åŸºç¡€å®ç°å’Œç»å…¸é—®é¢˜
- æ‹¬å·åŒ¹é…ã€ç”¨æ ˆå®ç°é˜Ÿåˆ—

**è¿›é˜¶ç¯‡**:
- å¾ªç¯é˜Ÿåˆ— - O(1) å‡ºé˜Ÿ
- å•è°ƒæ ˆ - ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´ 
- æœ€å°æ ˆ - O(1) è·å–æœ€å°å€¼
- å•è°ƒé˜Ÿåˆ— - æ»‘åŠ¨çª—å£æœ€å¤§å€¼

**å®æˆ˜ç¯‡**:
- æµè§ˆå™¨å†å²è®°å½•ç³»ç»Ÿ
- æ’¤é”€é‡åšç³»ç»Ÿ
- å¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ—
- LRU ç¼“å­˜
- å‡½æ•°è°ƒç”¨æ ˆè¿½è¸ª
- è¡¨è¾¾å¼æ±‚å€¼å™¨

---

## ä¸‹æœŸé¢„å‘Š

ä¸‹ä¸€ç¯‡æˆ‘ä»¬å°†å­¦ä¹ **é“¾è¡¨æ“ä½œ**,æ¢è®¨:
- é“¾è¡¨çš„åŸºæœ¬æ“ä½œ
- åŒå‘é“¾è¡¨ä¸å¾ªç¯é“¾è¡¨
- LRU ç¼“å­˜çš„é“¾è¡¨å®ç°
- React Fiber çš„é“¾è¡¨ç»“æ„

æ•¬è¯·æœŸå¾…!

---

**ç›¸å…³èµ„æº**:
- [å®Œæ•´ä»£ç ä»“åº“](https://github.com/yourname/frontend-algorithms)
- [åœ¨çº¿æ¼”ç¤º](https://demo.example.com)
- [LeetCode é¢˜å•](https://leetcode.cn/tag/stack/)
