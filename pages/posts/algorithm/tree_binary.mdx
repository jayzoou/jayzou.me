
# äºŒå‰æœç´¢æ ‘ - ä»åŸºç¡€åˆ°å®æˆ˜

## ä¸€ã€é—®é¢˜å¼•å…¥

ä½œä¸ºå‰ç«¯å¼€å‘å·¥ç¨‹å¸ˆ,ä½ å¯èƒ½é‡åˆ°è¿‡è¿™äº›åœºæ™¯:

### åœºæ™¯1: è‡ªåŠ¨å®Œæˆæœç´¢
```javascript
// ç”¨æˆ·è¾“å…¥ "rea",éœ€è¦å¿«é€Ÿæ‰¾åˆ°æ‰€æœ‰åŒ¹é…çš„å•è¯
const words = ['react', 'read', 'real', 'redux', 'vue', 'angular'];

// å¦‚ä½•é«˜æ•ˆåœ°å®ç°å‰ç¼€æœç´¢?
// çº¿æ€§æœç´¢: O(n)
// ä½¿ç”¨ BST: O(log n)
```

### åœºæ™¯2: èŒƒå›´æŸ¥è¯¢
```javascript
// æŸ¥æ‰¾ä»·æ ¼åœ¨ 100-500 ä¹‹é—´çš„æ‰€æœ‰å•†å“
const products = [
{ name: 'A', price: 150 },
{ name: 'B', price: 300 },
{ name: 'C', price: 800 },
// ... 10000 ä¸ªå•†å“
];

// å¦‚ä½•å¿«é€Ÿæ‰¾åˆ°èŒƒå›´å†…çš„å•†å“?
```

### åœºæ™¯3: æœ‰åºæ•°æ®ç»´æŠ¤
```javascript
// å®æ—¶æ’è¡Œæ¦œ,éœ€è¦é¢‘ç¹æ’å…¥å’ŒæŸ¥è¯¢æ’å
class Leaderboard {
insert(score: number): void;      // æ’å…¥æ–°åˆ†æ•°
getRank(score: number): number;   // æŸ¥è¯¢æ’å
getTopK(k: number): number[];     // è·å–å‰Kå
}

// å¦‚ä½•é«˜æ•ˆå®ç°?
```

### åœºæ™¯4: æ•°æ®åº“ç´¢å¼•
```javascript
// Bæ ‘/B+æ ‘æ˜¯ BST çš„å˜ä½“,ç”¨äºæ•°æ®åº“ç´¢å¼•
// MySQL çš„ InnoDB å¼•æ“ä½¿ç”¨ B+ æ ‘

SELECT * FROM users WHERE age BETWEEN 20 AND 30;
// å¦‚ä½•å¿«é€Ÿå®šä½æ•°æ®?
```

ä»Šå¤©æˆ‘ä»¬å°†æ·±å…¥å­¦ä¹ **äºŒå‰æœç´¢æ ‘ (BST)**,è¿™æ˜¯å®ç°é«˜æ•ˆæŸ¥æ‰¾çš„å…³é”®æ•°æ®ç»“æ„ã€‚

---

## äºŒã€ç®—æ³•åŸç†

### ä»€ä¹ˆæ˜¯äºŒå‰æœç´¢æ ‘?

äºŒå‰æœç´¢æ ‘ (Binary Search Tree, BST) æ˜¯ä¸€ç§ç‰¹æ®Šçš„äºŒå‰æ ‘,æ»¡è¶³:

```
å¯¹äºä»»æ„èŠ‚ç‚¹:
- å·¦å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹å€¼ < å½“å‰èŠ‚ç‚¹å€¼
- å³å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹å€¼ > å½“å‰èŠ‚ç‚¹å€¼
- å·¦å³å­æ ‘ä¹Ÿéƒ½æ˜¯ BST

ç¤ºä¾‹:
        5
      / \
      3   7
    / \ / \
    2  4 6  8

- 3 < 5 < 7
- 2 < 3 < 4
- 6 < 7 < 8
```

### BST çš„æ€§è´¨

1. **ä¸­åºéå†å¾—åˆ°æœ‰åºåºåˆ—**
```
ä¸­åºéå†: 2, 3, 4, 5, 6, 7, 8 (å‡åº)
```

2. **æŸ¥æ‰¾æ•ˆç‡é«˜**
```
æŸ¥æ‰¾ 6:
5 â†’ 7 â†’ 6  (åªéœ€3æ­¥)

æ¯”çº¿æ€§æŸ¥æ‰¾å¿«:
5 â†’ 3 â†’ 2 â†’ 4 â†’ 7 â†’ 6  (éœ€è¦6æ­¥)
```

3. **æ”¯æŒé«˜æ•ˆçš„èŒƒå›´æŸ¥è¯¢**
```
æŸ¥æ‰¾ 3-6 ä¹‹é—´çš„æ‰€æœ‰å€¼:
ä» 3 å¼€å§‹,ä¸­åºéå†åˆ° 6 å³å¯
```

### BST vs æ™®é€šäºŒå‰æ ‘

| ç‰¹æ€§ | æ™®é€šäºŒå‰æ ‘ | BST |
|------|-----------|-----|
| èŠ‚ç‚¹é¡ºåº | æ— è¦æ±‚ | å·¦ < æ ¹ < å³ |
| æŸ¥æ‰¾ | O(n) | O(log n) ~ O(n) |
| æ’å…¥ | O(1) | O(log n) ~ O(n) |
| åˆ é™¤ | O(n) | O(log n) ~ O(n) |
| ä¸­åºéå† | æ— åº | æœ‰åº |

### BST çš„æœ€åæƒ…å†µ

```
å¹³è¡¡çš„ BST:              é€€åŒ–æˆé“¾è¡¨:
    5                      1
  / \                      \
  3   7                      2
/ \ / \                      \
2  4 6  8                      3
                                \
é«˜åº¦: O(log n)                    4
æŸ¥æ‰¾: O(log n)                     \
                                  5
                              
                              é«˜åº¦: O(n)
                              æŸ¥æ‰¾: O(n)
```

**è§£å†³æ–¹æ¡ˆ**: è‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘ (AVLæ ‘ã€çº¢é»‘æ ‘)

---

## ä¸‰ã€ä»£ç å®ç°

### 1. BST èŠ‚ç‚¹å®šä¹‰

```typescript
/**
* BST èŠ‚ç‚¹
*/
class BSTNode<T> {
value: T;
left: BSTNode<T> | null = null;
right: BSTNode<T> | null = null;

constructor(value: T) {
  this.value = value;
}
}

/**
* äºŒå‰æœç´¢æ ‘
*/
class BinarySearchTree<T> {
root: BSTNode<T> | null = null;
private compareFn: (a: T, b: T) => number;

constructor(compareFn?: (a: T, b: T) => number) {
  // é»˜è®¤æ¯”è¾ƒå‡½æ•°
  this.compareFn = compareFn || ((a, b) => {
    if (a < b) return -1;
    if (a > b) return 1;
    return 0;
  });
}
}
```

---

### 2. æ’å…¥æ“ä½œ

```typescript
/**
* æ’å…¥èŠ‚ç‚¹ - é€’å½’ç‰ˆæœ¬
*/
insert(value: T): void {
this.root = this.insertNode(this.root, value);
}

private insertNode(node: BSTNode<T> | null, value: T): BSTNode<T> {
// æ‰¾åˆ°æ’å…¥ä½ç½®,åˆ›å»ºæ–°èŠ‚ç‚¹
if (!node) {
  return new BSTNode(value);
}

const cmp = this.compareFn(value, node.value);

if (cmp < 0) {
  // æ’å…¥å·¦å­æ ‘
  node.left = this.insertNode(node.left, value);
} else if (cmp > 0) {
  // æ’å…¥å³å­æ ‘
  node.right = this.insertNode(node.right, value);
}
// cmp === 0: å€¼å·²å­˜åœ¨,ä¸æ’å…¥(å¯æ ¹æ®éœ€æ±‚ä¿®æ”¹)

return node;
}

/**
* æ’å…¥èŠ‚ç‚¹ - è¿­ä»£ç‰ˆæœ¬
*/
insertIterative(value: T): void {
const newNode = new BSTNode(value);

if (!this.root) {
  this.root = newNode;
  return;
}

let current = this.root;

while (true) {
  const cmp = this.compareFn(value, current.value);
  
  if (cmp < 0) {
    if (!current.left) {
      current.left = newNode;
      return;
    }
    current = current.left;
  } else if (cmp > 0) {
    if (!current.right) {
      current.right = newNode;
      return;
    }
    current = current.right;
  } else {
    return; // å€¼å·²å­˜åœ¨
  }
}
}
```

**å¯è§†åŒ–æ’å…¥è¿‡ç¨‹**:
```
æ’å…¥åºåˆ—: 5, 3, 7, 2, 4, 6, 8

æ’å…¥ 5:
  5

æ’å…¥ 3 (3 < 5, æ’å…¥å·¦è¾¹):
  5
  /
3

æ’å…¥ 7 (7 > 5, æ’å…¥å³è¾¹):
  5
  / \
3   7

æ’å…¥ 2 (2 < 5, 2 < 3, æ’å…¥å·¦è¾¹):
  5
  / \
3   7
/
2

æ’å…¥ 4 (4 < 5, 4 > 3, æ’å…¥å³è¾¹):
  5
  / \
3   7
/ \
2   4

æœ€ç»ˆç»“æœ:
    5
  / \
  3   7
/ \ / \
2  4 6  8
```

---

### 3. æŸ¥æ‰¾æ“ä½œ

```typescript
/**
* æŸ¥æ‰¾èŠ‚ç‚¹ - é€’å½’ç‰ˆæœ¬
*/
search(value: T): boolean {
return this.searchNode(this.root, value) !== null;
}

private searchNode(node: BSTNode<T> | null, value: T): BSTNode<T> | null {
if (!node) {
  return null;
}

const cmp = this.compareFn(value, node.value);

if (cmp < 0) {
  return this.searchNode(node.left, value);
} else if (cmp > 0) {
  return this.searchNode(node.right, value);
} else {
  return node; // æ‰¾åˆ°äº†
}
}

/**
* æŸ¥æ‰¾èŠ‚ç‚¹ - è¿­ä»£ç‰ˆæœ¬
*/
searchIterative(value: T): boolean {
let current = this.root;

while (current) {
  const cmp = this.compareFn(value, current.value);
  
  if (cmp < 0) {
    current = current.left;
  } else if (cmp > 0) {
    current = current.right;
  } else {
    return true; // æ‰¾åˆ°äº†
  }
}

return false;
}
```

**æŸ¥æ‰¾è¿‡ç¨‹å¯è§†åŒ–**:
```
æŸ¥æ‰¾ 6:
    5          5 < 6, å‘å³
  / \
  3   7        7 > 6, å‘å·¦
/ \ / \
2  4 6  8      æ‰¾åˆ° 6!

è·¯å¾„: 5 â†’ 7 â†’ 6 (3æ­¥)
```

---

### 4. åˆ é™¤æ“ä½œ

åˆ é™¤æ˜¯ BST ä¸­æœ€å¤æ‚çš„æ“ä½œ,éœ€è¦è€ƒè™‘ä¸‰ç§æƒ…å†µ:

```typescript
/**
* åˆ é™¤èŠ‚ç‚¹
*/
delete(value: T): void {
this.root = this.deleteNode(this.root, value);
}

private deleteNode(node: BSTNode<T> | null, value: T): BSTNode<T> | null {
if (!node) {
  return null;
}

const cmp = this.compareFn(value, node.value);

if (cmp < 0) {
  // åœ¨å·¦å­æ ‘ä¸­åˆ é™¤
  node.left = this.deleteNode(node.left, value);
  return node;
} else if (cmp > 0) {
  // åœ¨å³å­æ ‘ä¸­åˆ é™¤
  node.right = this.deleteNode(node.right, value);
  return node;
} else {
  // æ‰¾åˆ°è¦åˆ é™¤çš„èŠ‚ç‚¹
  
  // æƒ…å†µ1: å¶å­èŠ‚ç‚¹(æ— å­èŠ‚ç‚¹)
  if (!node.left && !node.right) {
    return null;
  }
  
  // æƒ…å†µ2: åªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹
  if (!node.left) {
    return node.right;
  }
  if (!node.right) {
    return node.left;
  }
  
  // æƒ…å†µ3: æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹
  // æ‰¾åˆ°å³å­æ ‘çš„æœ€å°èŠ‚ç‚¹(åç»§èŠ‚ç‚¹)
  const minRight = this.findMin(node.right);
  
  // ç”¨åç»§èŠ‚ç‚¹çš„å€¼æ›¿æ¢å½“å‰èŠ‚ç‚¹
  node.value = minRight.value;
  
  // åˆ é™¤åç»§èŠ‚ç‚¹
  node.right = this.deleteNode(node.right, minRight.value);
  
  return node;
}
}

/**
* æ‰¾åˆ°æœ€å°èŠ‚ç‚¹
*/
private findMin(node: BSTNode<T>): BSTNode<T> {
while (node.left) {
  node = node.left;
}
return node;
}

/**
* æ‰¾åˆ°æœ€å¤§èŠ‚ç‚¹
*/
private findMax(node: BSTNode<T>): BSTNode<T> {
while (node.right) {
  node = node.right;
}
return node;
}
```

**åˆ é™¤æ“ä½œå¯è§†åŒ–**:

```
åŸå§‹æ ‘:
    5
  / \
  3   7
/ \ / \
2  4 6  8

æƒ…å†µ1: åˆ é™¤å¶å­èŠ‚ç‚¹ (åˆ é™¤ 2)
    5
  / \
  3   7
  \ / \
  4 6  8

æƒ…å†µ2: åˆ é™¤åªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹çš„èŠ‚ç‚¹ (åˆ é™¤ 3)
    5
  / \
  4   7
    / \
    6   8

æƒ…å†µ3: åˆ é™¤æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹çš„èŠ‚ç‚¹ (åˆ é™¤ 5)
æ­¥éª¤:
1. æ‰¾åˆ°å³å­æ ‘çš„æœ€å°èŠ‚ç‚¹ (6)
2. ç”¨ 6 æ›¿æ¢ 5
3. åˆ é™¤åŸæ¥çš„ 6

ç»“æœ:
    6
  / \
  4   7
      \
        8
```

---

### 5. æœ€å°å€¼å’Œæœ€å¤§å€¼

```typescript
/**
* è·å–æœ€å°å€¼
*/
min(): T | null {
if (!this.root) return null;

const minNode = this.findMin(this.root);
return minNode.value;
}

/**
* è·å–æœ€å¤§å€¼
*/
max(): T | null {
if (!this.root) return null;

const maxNode = this.findMax(this.root);
return maxNode.value;
}
```

---

### 6. ä¸­åºéå†(å¾—åˆ°æœ‰åºåºåˆ—)

```typescript
/**
* ä¸­åºéå† - è¿”å›æœ‰åºæ•°ç»„
*/
inorderTraversal(): T[] {
const result: T[] = [];

function traverse(node: BSTNode<T> | null) {
  if (!node) return;
  
  traverse(node.left);
  result.push(node.value);
  traverse(node.right);
}

traverse(this.root);
return result;
}

/**
* ä¸­åºéå† - è¿­ä»£ç‰ˆæœ¬
*/
inorderTraversalIterative(): T[] {
const result: T[] = [];
const stack: BSTNode<T>[] = [];
let current = this.root;

while (current || stack.length > 0) {
  while (current) {
    stack.push(current);
    current = current.left;
  }
  
  current = stack.pop()!;
  result.push(current.value);
  current = current.right;
}

return result;
}
```

---

### 7. èŒƒå›´æŸ¥è¯¢

```typescript
/**
* èŒƒå›´æŸ¥è¯¢ - æŸ¥æ‰¾ [min, max] ä¹‹é—´çš„æ‰€æœ‰å€¼
*/
rangeSearch(min: T, max: T): T[] {
const result: T[] = [];

const traverse = (node: BSTNode<T> | null) => {
  if (!node) return;
  
  // å¦‚æœå½“å‰èŠ‚ç‚¹å€¼ > min,å¯èƒ½åœ¨å·¦å­æ ‘ä¸­æœ‰ç¬¦åˆæ¡ä»¶çš„èŠ‚ç‚¹
  if (this.compareFn(node.value, min) > 0) {
    traverse(node.left);
  }
  
  // å¦‚æœå½“å‰èŠ‚ç‚¹åœ¨èŒƒå›´å†…,åŠ å…¥ç»“æœ
  if (
    this.compareFn(node.value, min) >= 0 &&
    this.compareFn(node.value, max) <= 0
  ) {
    result.push(node.value);
  }
  
  // å¦‚æœå½“å‰èŠ‚ç‚¹å€¼ < max,å¯èƒ½åœ¨å³å­æ ‘ä¸­æœ‰ç¬¦åˆæ¡ä»¶çš„èŠ‚ç‚¹
  if (this.compareFn(node.value, max) < 0) {
    traverse(node.right);
  }
};

traverse(this.root);
return result;
}
```

**èŒƒå›´æŸ¥è¯¢å¯è§†åŒ–**:
```
æ ‘:     5
      / \
    3   7
    / \ / \
  2  4 6  8

æŸ¥æ‰¾ 3-6:
1. ä»æ ¹èŠ‚ç‚¹ 5 å¼€å§‹
2. 5 åœ¨èŒƒå›´å†…,åŠ å…¥ç»“æœ: [5]
3. 5 > 3,æ£€æŸ¥å·¦å­æ ‘
  - 3 åœ¨èŒƒå›´å†…: [5, 3]
  - 3 çš„å³å­æ ‘: 4 åœ¨èŒƒå›´å†…: [5, 3, 4]
4. 5 < 6,æ£€æŸ¥å³å­æ ‘
  - 7 > 6,åªæ£€æŸ¥å·¦å­æ ‘
  - 6 åœ¨èŒƒå›´å†…: [5, 3, 4, 6]

ç»“æœ(ä¸­åº): [3, 4, 5, 6]
```

---

### 8. éªŒè¯ BST

```typescript
/**
* éªŒè¯æ˜¯å¦ä¸ºæœ‰æ•ˆçš„ BST
*/
isValidBST(): boolean {
function validate(
  node: BSTNode<T> | null,
  min: T | null,
  max: T | null
): boolean {
  if (!node) return true;
  
  // æ£€æŸ¥å½“å‰èŠ‚ç‚¹æ˜¯å¦åœ¨æœ‰æ•ˆèŒƒå›´å†…
  if (min !== null && this.compareFn(node.value, min) <= 0) {
    return false;
  }
  if (max !== null && this.compareFn(node.value, max) >= 0) {
    return false;
  }
  
  // é€’å½’æ£€æŸ¥å·¦å³å­æ ‘
  return (
    validate(node.left, min, node.value) &&
    validate(node.right, node.value, max)
  );
}

return validate.call(this, this.root, null, null);
}
```

---

### 9. å®Œæ•´çš„ BST ç±»

```typescript
/**
* å®Œæ•´çš„äºŒå‰æœç´¢æ ‘å®ç°
*/
class BinarySearchTree<T> {
root: BSTNode<T> | null = null;
private compareFn: (a: T, b: T) => number;
private size: number = 0;

constructor(compareFn?: (a: T, b: T) => number) {
  this.compareFn = compareFn || ((a, b) => {
    if (a < b) return -1;
    if (a > b) return 1;
    return 0;
  });
}

// ... (ä¸Šé¢å®ç°çš„æ‰€æœ‰æ–¹æ³•)

/**
  * è·å–èŠ‚ç‚¹æ•°é‡
  */
getSize(): number {
  return this.size;
}

/**
  * åˆ¤æ–­æ˜¯å¦ä¸ºç©º
  */
isEmpty(): boolean {
  return this.root === null;
}

/**
  * æ¸…ç©ºæ ‘
  */
clear(): void {
  this.root = null;
  this.size = 0;
}

/**
  * è·å–é«˜åº¦
  */
height(): number {
  function getHeight(node: BSTNode<T> | null): number {
    if (!node) return 0;
    return 1 + Math.max(getHeight(node.left), getHeight(node.right));
  }
  
  return getHeight(this.root);
}

/**
  * æ‰“å°æ ‘ç»“æ„
  */
print(): void {
  function printNode(
    node: BSTNode<T> | null,
    prefix: string = '',
    isLeft: boolean = true
  ) {
    if (!node) return;
    
    console.log(prefix + (isLeft ? 'â”œâ”€â”€ ' : 'â””â”€â”€ ') + node.value);
    
    if (node.left || node.right) {
      if (node.left) {
        printNode(node.left, prefix + (isLeft ? 'â”‚   ' : '    '), true);
      }
      if (node.right) {
        printNode(node.right, prefix + (isLeft ? 'â”‚   ' : '    '), false);
      }
    }
  }
  
  if (!this.root) {
    console.log('Empty tree');
    return;
  }
  
  console.log(this.root.value);
  if (this.root.left) {
    printNode(this.root.left, '', true);
  }
  if (this.root.right) {
    printNode(this.root.right, '', false);
  }
}
}

// æµ‹è¯•
const bst = new BinarySearchTree<number>();

// æ’å…¥èŠ‚ç‚¹
[5, 3, 7, 2, 4, 6, 8].forEach(val => bst.insert(val));

// æ‰“å°æ ‘
bst.print();
// 5
// â”œâ”€â”€ 3
// â”‚   â”œâ”€â”€ 2
// â”‚   â””â”€â”€ 4
// â””â”€â”€ 7
//     â”œâ”€â”€ 6
//     â””â”€â”€ 8

// æŸ¥æ‰¾
console.log(bst.search(6));  // true
console.log(bst.search(10)); // false

// æœ€å°å€¼å’Œæœ€å¤§å€¼
console.log(bst.min()); // 2
console.log(bst.max()); // 8

// ä¸­åºéå†(æœ‰åº)
console.log(bst.inorderTraversal()); // [2, 3, 4, 5, 6, 7, 8]

// èŒƒå›´æŸ¥è¯¢
console.log(bst.rangeSearch(3, 6)); // [3, 4, 5, 6]

// åˆ é™¤
bst.delete(3);
console.log(bst.inorderTraversal()); // [2, 4, 5, 6, 7, 8]
```

---

## å››ã€å¤æ‚åº¦åˆ†æ

### æ—¶é—´å¤æ‚åº¦

<table>
  <thead>
    <tr>
      <th>æ“ä½œ</th>
      <th>å¹³å‡æƒ…å†µ</th>
      <th>æœ€åæƒ…å†µ</th>
      <th>è¯´æ˜</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>æŸ¥æ‰¾</td>
      <td>O(log n)</td>
      <td>O(n)</td>
      <td>é€€åŒ–æˆé“¾è¡¨</td>
    </tr>
    <tr>
      <td>æ’å…¥</td>
      <td>O(log n)</td>
      <td>O(n)</td>
      <td>é€€åŒ–æˆé“¾è¡¨</td>
    </tr>
    <tr>
      <td>åˆ é™¤</td>
      <td>O(log n)</td>
      <td>O(n)</td>
      <td>é€€åŒ–æˆé“¾è¡¨</td>
    </tr>
    <tr>
      <td>æœ€å°/æœ€å¤§</td>
      <td>O(log n)</td>
      <td>O(n)</td>
      <td>é€€åŒ–æˆé“¾è¡¨</td>
    </tr>
    <tr>
      <td>ä¸­åºéå†</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>è®¿é—®æ‰€æœ‰èŠ‚ç‚¹</td>
    </tr>
    <tr>
      <td>èŒƒå›´æŸ¥è¯¢</td>
      <td>O(log n + k)</td>
      <td>O(n)</td>
      <td>k ä¸ºç»“æœæ•°é‡</td>
    </tr>
  </tbody>
</table>

### ç©ºé—´å¤æ‚åº¦

- **å­˜å‚¨**: O(n) - å­˜å‚¨ n ä¸ªèŠ‚ç‚¹
- **é€’å½’æ ˆ**: O(h) - h ä¸ºæ ‘çš„é«˜åº¦
- å¹³è¡¡æ ‘: O(log n)
- é€€åŒ–æ ‘: O(n)

### BST vs å…¶ä»–æ•°æ®ç»“æ„

<table>
  <thead>
    <tr>
      <th>æ•°æ®ç»“æ„</th>
      <th>æŸ¥æ‰¾</th>
      <th>æ’å…¥</th>
      <th>åˆ é™¤</th>
      <th>æœ‰åºéå†</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>æ•°ç»„(æ— åº)</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>O(n)</td>
      <td>O(n log n)</td>
    </tr>
    <tr>
      <td>æ•°ç»„(æœ‰åº)</td>
      <td>O(log n)</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>é“¾è¡¨</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>O(n)</td>
      <td>O(n log n)</td>
    </tr>
    <tr>
      <td>BST</td>
      <td>O(log n)</td>
      <td>O(log n)</td>
      <td>O(log n)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>å“ˆå¸Œè¡¨</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>O(1)</td>
      <td>âœ— ä¸æ”¯æŒ</td>
    </tr>
  </tbody>
</table>

**BST çš„ä¼˜åŠ¿**:
- âœ… æ”¯æŒé«˜æ•ˆçš„èŒƒå›´æŸ¥è¯¢
- âœ… æ”¯æŒæœ‰åºéå†
- âœ… æ”¯æŒå‰é©±/åç»§æŸ¥è¯¢
- âœ… åŠ¨æ€ç»´æŠ¤æœ‰åºæ•°æ®

---

## äº”ã€å®æˆ˜åº”ç”¨

### æ¡ˆä¾‹1: è‡ªåŠ¨å®Œæˆç³»ç»Ÿ

```typescript
/**
* è‡ªåŠ¨å®Œæˆç³»ç»Ÿ
* ä½¿ç”¨ BST å­˜å‚¨å•è¯,æ”¯æŒå‰ç¼€æœç´¢
*/
class AutoComplete {
private bst: BinarySearchTree<string>;

constructor() {
  this.bst = new BinarySearchTree<string>();
}

/**
  * æ·»åŠ å•è¯
  */
addWord(word: string): void {
  this.bst.insert(word.toLowerCase());
}

/**
  * æ‰¹é‡æ·»åŠ å•è¯
  */
addWords(words: string[]): void {
  words.forEach(word => this.addWord(word));
}

/**
  * å‰ç¼€æœç´¢
  */
searchPrefix(prefix: string): string[] {
  prefix = prefix.toLowerCase();
  const result: string[] = [];
  
  // æ‰¾åˆ°ç¬¬ä¸€ä¸ª >= prefix çš„å•è¯
  const startWord = prefix;
  
  // æ‰¾åˆ°ç¬¬ä¸€ä¸ª > prefix çš„å•è¯(é€šè¿‡å¢åŠ ä¸€ä¸ªå­—ç¬¦)
  const endWord = prefix.slice(0, -1) + 
    String.fromCharCode(prefix.charCodeAt(prefix.length - 1) + 1);
  
  // èŒƒå›´æŸ¥è¯¢
  const matches = this.bst.rangeSearch(startWord, endWord);
  
  // è¿‡æ»¤å‡ºçœŸæ­£ä»¥ prefix å¼€å¤´çš„å•è¯
  return matches.filter(word => word.startsWith(prefix));
}

/**
  * æ¨¡ç³Šæœç´¢(ç¼–è¾‘è·ç¦»)
  */
fuzzySearch(query: string, maxDistance: number = 2): string[] {
  const allWords = this.bst.inorderTraversal();
  const result: string[] = [];
  
  for (const word of allWords) {
    if (this.editDistance(query, word) <= maxDistance) {
      result.push(word);
    }
  }
  
  return result;
}

/**
  * è®¡ç®—ç¼–è¾‘è·ç¦»(Levenshteinè·ç¦»)
  */
private editDistance(s1: string, s2: string): number {
  const m = s1.length;
  const n = s2.length;
  const dp: number[][] = Array.from({ length: m + 1 }, () => 
    Array(n + 1).fill(0)
  );
  
  for (let i = 0; i <= m; i++) dp[i][0] = i;
  for (let j = 0; j <= n; j++) dp[0][j] = j;
  
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (s1[i - 1] === s2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        dp[i][j] = Math.min(
          dp[i - 1][j] + 1,     // åˆ é™¤
          dp[i][j - 1] + 1,     // æ’å…¥
          dp[i - 1][j - 1] + 1  // æ›¿æ¢
        );
      }
    }
  }
  
  return dp[m][n];
}

/**
  * è·å–å»ºè®®(æŒ‰é¢‘ç‡æ’åº)
  */
getSuggestions(prefix: string, limit: number = 10): string[] {
  const matches = this.searchPrefix(prefix);
  return matches.slice(0, limit);
}
}

// æµ‹è¯•
const autoComplete = new AutoComplete();

autoComplete.addWords([
'react', 'read', 'real', 'redux', 'reduce',
'vue', 'vuex', 'angular', 'apple', 'application'
]);

console.log(autoComplete.searchPrefix('re'));
// ['react', 'read', 'real', 'reduce', 'redux']

console.log(autoComplete.searchPrefix('rea'));
// ['react', 'read', 'real']

console.log(autoComplete.fuzzySearch('raect', 1));
// ['react'] (ç¼–è¾‘è·ç¦»ä¸º1)
```

---

### æ¡ˆä¾‹2: æ’è¡Œæ¦œç³»ç»Ÿ

```typescript
/**
* æ’è¡Œæ¦œç³»ç»Ÿ
* ä½¿ç”¨ BST ç»´æŠ¤åˆ†æ•°æ’åº
*/
interface Player {
id: string;
name: string;
score: number;
}

class Leaderboard {
private bst: BinarySearchTree<Player>;
private playerMap: Map<string, Player>;

constructor() {
  // æŒ‰åˆ†æ•°æ’åº
  this.bst = new BinarySearchTree<Player>((a, b) => {
    if (a.score !== b.score) {
      return b.score - a.score; // é™åº
    }
    return a.id.localeCompare(b.id); // åˆ†æ•°ç›¸åŒæŒ‰IDæ’åº
  });
  
  this.playerMap = new Map();
}

/**
  * æ·»åŠ æˆ–æ›´æ–°ç©å®¶åˆ†æ•°
  */
updateScore(id: string, name: string, score: number): void {
  // å¦‚æœç©å®¶å·²å­˜åœ¨,å…ˆåˆ é™¤æ—§è®°å½•
  if (this.playerMap.has(id)) {
    const oldPlayer = this.playerMap.get(id)!;
    this.bst.delete(oldPlayer);
  }
  
  // æ·»åŠ æ–°è®°å½•
  const player: Player = { id, name, score };
  this.bst.insert(player);
  this.playerMap.set(id, player);
}

/**
  * è·å–ç©å®¶æ’å
  */
getRank(id: string): number {
  const player = this.playerMap.get(id);
  if (!player) return -1;
  
  const allPlayers = this.bst.inorderTraversal();
  return allPlayers.findIndex(p => p.id === id) + 1;
}

/**
  * è·å–å‰Kå
  */
getTopK(k: number): Player[] {
  const allPlayers = this.bst.inorderTraversal();
  return allPlayers.slice(0, k);
}

/**
  * è·å–åˆ†æ•°èŒƒå›´å†…çš„ç©å®¶
  */
getPlayersInRange(minScore: number, maxScore: number): Player[] {
  const dummyMin: Player = { id: '', name: '', score: minScore };
  const dummyMax: Player = { id: '', name: '', score: maxScore };
  
  return this.bst.rangeSearch(dummyMax, dummyMin); // æ³¨æ„é¡ºåº(é™åº)
}

/**
  * è·å–ç©å®¶ä¿¡æ¯
  */
getPlayer(id: string): Player | undefined {
  return this.playerMap.get(id);
}

/**
  * æ‰“å°æ’è¡Œæ¦œ
  */
printLeaderboard(limit: number = 10): void {
  const topPlayers = this.getTopK(limit);
  
  console.log('\nğŸ† æ’è¡Œæ¦œ Top', limit);
  console.log('â”€'.repeat(50));
  
  topPlayers.forEach((player, index) => {
    const rank = index + 1;
    const medal = rank === 1 ? 'ğŸ¥‡' : rank === 2 ? 'ğŸ¥ˆ' : rank === 3 ? 'ğŸ¥‰' : '  ';
    console.log(`${medal} ${rank}. ${player.name.padEnd(20)} ${player.score} åˆ†`);
  });
  
  console.log('â”€'.repeat(50));
}
}

// æµ‹è¯•
const leaderboard = new Leaderboard();

// æ·»åŠ ç©å®¶
leaderboard.updateScore('p1', 'Alice', 1500);
leaderboard.updateScore('p2', 'Bob', 1200);
leaderboard.updateScore('p3', 'Charlie', 1800);
leaderboard.updateScore('p4', 'David', 1600);
leaderboard.updateScore('p5', 'Eve', 1400);

// æ‰“å°æ’è¡Œæ¦œ
leaderboard.printLeaderboard(5);
// ğŸ¥‡ 1. Charlie             1800 åˆ†
// ğŸ¥ˆ 2. David               1600 åˆ†
// ğŸ¥‰ 3. Alice               1500 åˆ†
//    4. Eve                 1400 åˆ†
//    5. Bob                 1200 åˆ†

// æ›´æ–°åˆ†æ•°
leaderboard.updateScore('p2', 'Bob', 2000);
leaderboard.printLeaderboard(5);
// ğŸ¥‡ 1. Bob                 2000 åˆ†
// ğŸ¥ˆ 2. Charlie             1800 åˆ†
// ...

// è·å–æ’å
console.log('Bob çš„æ’å:', leaderboard.getRank('p2')); // 1

// èŒƒå›´æŸ¥è¯¢
const midRange = leaderboard.getPlayersInRange(1400, 1600);
console.log('1400-1600åˆ†çš„ç©å®¶:', midRange.map(p => p.name));
```

---

### æ¡ˆä¾‹3: åŒºé—´è°ƒåº¦é—®é¢˜

```typescript
/**
* ä¼šè®®å®¤è°ƒåº¦ç³»ç»Ÿ
* ä½¿ç”¨ BST ç®¡ç†æ—¶é—´åŒºé—´
*/
interface Meeting {
id: string;
title: string;
start: number;  // å¼€å§‹æ—¶é—´(æ—¶é—´æˆ³)
end: number;    // ç»“æŸæ—¶é—´
}

class MeetingScheduler {
private bst: BinarySearchTree<Meeting>;

constructor() {
  // æŒ‰å¼€å§‹æ—¶é—´æ’åº
  this.bst = new BinarySearchTree<Meeting>((a, b) => a.start - b.start);
}

/**
  * é¢„è®¢ä¼šè®®
  */
book(meeting: Meeting): boolean {
  // æ£€æŸ¥æ˜¯å¦æœ‰å†²çª
  if (this.hasConflict(meeting.start, meeting.end)) {
    console.log(`âŒ é¢„è®¢å¤±è´¥: ${meeting.title} (æ—¶é—´å†²çª)`);
    return false;
  }
  
  this.bst.insert(meeting);
  console.log(`âœ… é¢„è®¢æˆåŠŸ: ${meeting.title}`);
  return true;
}

/**
  * æ£€æŸ¥æ—¶é—´å†²çª
  */
private hasConflict(start: number, end: number): boolean {
  const allMeetings = this.bst.inorderTraversal();
  
  for (const meeting of allMeetings) {
    // æ£€æŸ¥æ˜¯å¦æœ‰é‡å 
    if (!(end <= meeting.start || start >= meeting.end)) {
      return true;
    }
  }
  
  return false;
}

/**
  * æŸ¥æ‰¾æŒ‡å®šæ—¶é—´æ®µçš„æ‰€æœ‰ä¼šè®®
  */
findMeetings(start: number, end: number): Meeting[] {
  const allMeetings = this.bst.inorderTraversal();
  
  return allMeetings.filter(meeting => {
    // æœ‰é‡å å°±è¿”å›
    return !(end <= meeting.start || start >= meeting.end);
  });
}

/**
  * æŸ¥æ‰¾ç©ºé—²æ—¶é—´æ®µ
  */
findFreeSlots(start: number, end: number, duration: number): Array<{start: number, end: number}> {
  const meetings = this.findMeetings(start, end);
  const freeSlots: Array<{start: number, end: number}> = [];
  
  // æŒ‰å¼€å§‹æ—¶é—´æ’åº
  meetings.sort((a, b) => a.start - b.start);
  
  let currentTime = start;
  
  for (const meeting of meetings) {
    if (meeting.start > currentTime) {
      const slotDuration = meeting.start - currentTime;
      if (slotDuration >= duration) {
        freeSlots.push({
          start: currentTime,
          end: meeting.start
        });
      }
    }
    currentTime = Math.max(currentTime, meeting.end);
  }
  
  // æ£€æŸ¥æœ€åä¸€ä¸ªæ—¶é—´æ®µ
  if (end > currentTime && end - currentTime >= duration) {
    freeSlots.push({
      start: currentTime,
      end: end
    });
  }
  
  return freeSlots;
}

/**
  * å–æ¶ˆä¼šè®®
  */
cancel(meetingId: string): boolean {
  const allMeetings = this.bst.inorderTraversal();
  const meeting = allMeetings.find(m => m.id === meetingId);
  
  if (!meeting) {
    console.log(`âŒ å–æ¶ˆå¤±è´¥: ä¼šè®®ä¸å­˜åœ¨`);
    return false;
  }
  
  this.bst.delete(meeting);
  console.log(`âœ… å–æ¶ˆæˆåŠŸ: ${meeting.title}`);
  return true;
}

/**
  * æ‰“å°æ—¥ç¨‹è¡¨
  */
printSchedule(): void {
  const meetings = this.bst.inorderTraversal();
  
  console.log('\nğŸ“… ä¼šè®®æ—¥ç¨‹');
  console.log('â”€'.repeat(60));
  
  meetings.forEach(meeting => {
    const startTime = new Date(meeting.start).toLocaleTimeString();
    const endTime = new Date(meeting.end).toLocaleTimeString();
    console.log(`${startTime} - ${endTime}  ${meeting.title}`);
  });
  
  console.log('â”€'.repeat(60));
}
}

// æµ‹è¯•
const scheduler = new MeetingScheduler();

const now = Date.now();
const hour = 60 * 60 * 1000;

scheduler.book({
id: 'm1',
title: 'å›¢é˜Ÿç«™ä¼š',
start: now,
end: now + hour
});

scheduler.book({
id: 'm2',
title: 'é¡¹ç›®è¯„å®¡',
start: now + 2 * hour,
end: now + 3 * hour
});

scheduler.book({
id: 'm3',
title: 'å®¢æˆ·ä¼šè®®',
start: now + 0.5 * hour,  // å†²çª!
end: now + 1.5 * hour
});
// âŒ é¢„è®¢å¤±è´¥: å®¢æˆ·ä¼šè®® (æ—¶é—´å†²çª)

scheduler.printSchedule();

// æŸ¥æ‰¾ç©ºé—²æ—¶é—´
const freeSlots = scheduler.findFreeSlots(now, now + 5 * hour, 0.5 * hour);
console.log('\nğŸ• ç©ºé—²æ—¶é—´æ®µ:');
freeSlots.forEach(slot => {
const start = new Date(slot.start).toLocaleTimeString();
const end = new Date(slot.end).toLocaleTimeString();
console.log(`${start} - ${end}`);
});
```

---

### æ¡ˆä¾‹4: ä»·æ ¼åŒºé—´æŸ¥è¯¢

```typescript
/**
* å•†å“ä»·æ ¼ç´¢å¼•
* æ”¯æŒå¿«é€Ÿçš„ä»·æ ¼èŒƒå›´æŸ¥è¯¢
*/
interface Product {
id: string;
name: string;
price: number;
category: string;
}

class ProductPriceIndex {
private bst: BinarySearchTree<Product>;
private productMap: Map<string, Product>;

constructor() {
  // æŒ‰ä»·æ ¼æ’åº
  this.bst = new BinarySearchTree<Product>((a, b) => {
    if (a.price !== b.price) {
      return a.price - b.price;
    }
    return a.id.localeCompare(b.id);
  });
  
  this.productMap = new Map();
}

/**
  * æ·»åŠ å•†å“
  */
addProduct(product: Product): void {
  this.bst.insert(product);
  this.productMap.set(product.id, product);
}

/**
  * æ‰¹é‡æ·»åŠ 
  */
addProducts(products: Product[]): void {
  products.forEach(p => this.addProduct(p));
}

/**
  * ä»·æ ¼èŒƒå›´æŸ¥è¯¢
  */
findByPriceRange(minPrice: number, maxPrice: number): Product[] {
  const dummyMin: Product = { id: '', name: '', price: minPrice, category: '' };
  const dummyMax: Product = { id: '', name: '', price: maxPrice, category: '' };
  
  return this.bst.rangeSearch(dummyMin, dummyMax);
}

/**
  * æŸ¥æ‰¾æœ€ä¾¿å®œçš„å•†å“
  */
findCheapest(): Product | null {
  const min = this.bst.min();
  return min || null;
}

/**
  * æŸ¥æ‰¾æœ€è´µçš„å•†å“
  */
findMostExpensive(): Product | null {
  const max = this.bst.max();
  return max || null;
}

/**
  * æŸ¥æ‰¾ä»·æ ¼ä¸­ä½æ•°
  */
findMedianPrice(): number {
  const allProducts = this.bst.inorderTraversal();
  const mid = Math.floor(allProducts.length / 2);
  
  if (allProducts.length % 2 === 0) {
    return (allProducts[mid - 1].price + allProducts[mid].price) / 2;
  }
  
  return allProducts[mid].price;
}

/**
  * ç»Ÿè®¡ä»·æ ¼åˆ†å¸ƒ
  */
getPriceDistribution(bucketSize: number): Map<string, number> {
  const allProducts = this.bst.inorderTraversal();
  const distribution = new Map<string, number>();
  
  for (const product of allProducts) {
    const bucket = Math.floor(product.price / bucketSize) * bucketSize;
    const key = `${bucket}-${bucket + bucketSize}`;
    distribution.set(key, (distribution.get(key) || 0) + 1);
  }
  
  return distribution;
}

/**
  * æ‰“å°ä»·æ ¼åˆ†å¸ƒ
  */
printPriceDistribution(bucketSize: number = 100): void {
  const distribution = this.getPriceDistribution(bucketSize);
  
  console.log('\nğŸ’° ä»·æ ¼åˆ†å¸ƒ');
  console.log('â”€'.repeat(50));
  
  Array.from(distribution.entries())
    .sort((a, b) => a[0].localeCompare(b[0]))
    .forEach(([range, count]) => {
      const bar = 'â–ˆ'.repeat(count);
      console.log(`${range.padEnd(15)} ${bar} (${count})`);
    });
  
  console.log('â”€'.repeat(50));
}
}

// æµ‹è¯•
const priceIndex = new ProductPriceIndex();

priceIndex.addProducts([
{ id: 'p1', name: 'é”®ç›˜', price: 299, category: 'ç”µè„‘é…ä»¶' },
{ id: 'p2', name: 'é¼ æ ‡', price: 99, category: 'ç”µè„‘é…ä»¶' },
{ id: 'p3', name: 'æ˜¾ç¤ºå™¨', price: 1299, category: 'ç”µè„‘é…ä»¶' },
{ id: 'p4', name: 'è€³æœº', price: 199, category: 'éŸ³é¢‘è®¾å¤‡' },
{ id: 'p5', name: 'Uç›˜', price: 49, category: 'å­˜å‚¨è®¾å¤‡' },
{ id: 'p6', name: 'ç§»åŠ¨ç¡¬ç›˜', price: 599, category: 'å­˜å‚¨è®¾å¤‡' },
{ id: 'p7', name: 'ç¬”è®°æœ¬', price: 5999, category: 'ç”µè„‘' },
{ id: 'p8', name: 'å¹³æ¿', price: 2999, category: 'ç”µè„‘' }
]);

// ä»·æ ¼èŒƒå›´æŸ¥è¯¢
console.log('\n100-500å…ƒçš„å•†å“:');
const range = priceIndex.findByPriceRange(100, 500);
range.forEach(p => console.log(`${p.name}: Â¥${p.price}`));

// æœ€ä¾¿å®œå’Œæœ€è´µ
console.log('\næœ€ä¾¿å®œ:', priceIndex.findCheapest()?.name);
console.log('æœ€è´µ:', priceIndex.findMostExpensive()?.name);

// ä¸­ä½æ•°
console.log('\nä»·æ ¼ä¸­ä½æ•°: Â¥', priceIndex.findMedianPrice());

// ä»·æ ¼åˆ†å¸ƒ
priceIndex.printPriceDistribution(1000);
```

---

## å…­ã€ç»ƒä¹ é¢˜

### é¢˜ç›®1: äºŒå‰æœç´¢æ ‘ä¸­ç¬¬Kå°çš„å…ƒç´  (LeetCode 230)

**éš¾åº¦**: ä¸­ç­‰

**é¢˜ç›®æè¿°**:
ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ root,å’Œä¸€ä¸ªæ•´æ•° k,è¿”å› BST ä¸­ç¬¬ k å°çš„å…ƒç´ ã€‚

```typescript
/**
* @param root - BST æ ¹èŠ‚ç‚¹
* @param k - ç¬¬ k å°
* @return ç¬¬ k å°çš„å…ƒç´ å€¼
*/
function kthSmallest(root: BSTNode<number> | null, k: number): number {
// åœ¨è¿™é‡Œå®ç°ä½ çš„ä»£ç 
}

// æµ‹è¯•ç”¨ä¾‹
// è¾“å…¥:    3
//        / \
//       1   4
//        \
//         2
// k = 1
// è¾“å‡º: 1
```

**æç¤º**: ä¸­åºéå†çš„ç¬¬ k ä¸ªå…ƒç´ å°±æ˜¯ç­”æ¡ˆ

<details>
<summary>ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary>

```typescript
function kthSmallest(root: BSTNode<number> | null, k: number): number {
let count = 0;
let result = 0;

function inorder(node: BSTNode<number> | null): boolean {
  if (!node) return false;
  
  // éå†å·¦å­æ ‘
  if (inorder(node.left)) return true;
  
  // è®¿é—®å½“å‰èŠ‚ç‚¹
  count++;
  if (count === k) {
    result = node.value;
    return true;
  }
  
  // éå†å³å­æ ‘
  return inorder(node.right);
}

inorder(root);
return result;
}
```

**æ—¶é—´å¤æ‚åº¦**: O(k)  
**ç©ºé—´å¤æ‚åº¦**: O(h) - h ä¸ºæ ‘é«˜
</details>

---

### é¢˜ç›®2: å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘ (LeetCode 108)

**éš¾åº¦**: ç®€å•

**é¢˜ç›®æè¿°**:
ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums,å…¶ä¸­å…ƒç´ å·²ç»æŒ‰å‡åºæ’åˆ—,å°†å…¶è½¬æ¢ä¸ºä¸€æ£µé«˜åº¦å¹³è¡¡çš„äºŒå‰æœç´¢æ ‘ã€‚

```typescript
/**
* @param nums - æœ‰åºæ•°ç»„
* @return BST æ ¹èŠ‚ç‚¹
*/
function sortedArrayToBST(nums: number[]): BSTNode<number> | null {
// åœ¨è¿™é‡Œå®ç°ä½ çš„ä»£ç 
}

// æµ‹è¯•ç”¨ä¾‹
// è¾“å…¥: [-10, -3, 0, 5, 9]
// è¾“å‡º:      0
//          / \
//        -3   9
//        /   /
//      -10  5
```

**æç¤º**: é€‰æ‹©ä¸­é—´å…ƒç´ ä½œä¸ºæ ¹èŠ‚ç‚¹,é€’å½’æ„å»ºå·¦å³å­æ ‘

---

### é¢˜ç›®3: æ¢å¤äºŒå‰æœç´¢æ ‘ (LeetCode 99)

**éš¾åº¦**: ä¸­ç­‰

**é¢˜ç›®æè¿°**:
ç»™ä½ äºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ root,è¯¥æ ‘ä¸­çš„æ°å¥½ä¸¤ä¸ªèŠ‚ç‚¹çš„å€¼è¢«é”™è¯¯åœ°äº¤æ¢ã€‚è¯·åœ¨ä¸æ”¹å˜å…¶ç»“æ„çš„æƒ…å†µä¸‹,æ¢å¤è¿™æ£µæ ‘ã€‚

```typescript
/**
* @param root - BST æ ¹èŠ‚ç‚¹
*/
function recoverTree(root: BSTNode<number> | null): void {
// åœ¨è¿™é‡Œå®ç°ä½ çš„ä»£ç 
}

// æµ‹è¯•ç”¨ä¾‹
// è¾“å…¥:  1        è¾“å‡º:  3
//       /                /
//      3                1
//       \                \
//        2                2
```

**æç¤º**: ä¸­åºéå†æ‰¾åˆ°ä¸¤ä¸ªé€†åºçš„èŠ‚ç‚¹,äº¤æ¢å®ƒä»¬çš„å€¼

---

## ä¸ƒã€æ€»ç»“ä¸æ‰©å±•

### æ ¸å¿ƒè¦ç‚¹

1. **BST çš„æ€§è´¨**:
  - å·¦å­æ ‘ < æ ¹ < å³å­æ ‘
  - ä¸­åºéå†å¾—åˆ°æœ‰åºåºåˆ—
  - æ”¯æŒé«˜æ•ˆçš„æŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤

2. **åŸºæœ¬æ“ä½œ**:
  - æ’å…¥: é€’å½’æˆ–è¿­ä»£
  - æŸ¥æ‰¾: äºŒåˆ†æŸ¥æ‰¾æ€æƒ³
  - åˆ é™¤: ä¸‰ç§æƒ…å†µå¤„ç†
  - éå†: ä¸­åºå¾—åˆ°æœ‰åºåºåˆ—

3. **å®æˆ˜åº”ç”¨**:
  - è‡ªåŠ¨å®Œæˆæœç´¢
  - æ’è¡Œæ¦œç³»ç»Ÿ
  - åŒºé—´è°ƒåº¦
  - ä»·æ ¼ç´¢å¼•

### BST çš„ä¼˜ç¼ºç‚¹

**ä¼˜ç‚¹**:
- âœ… æŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤å¹³å‡ O(log n)
- âœ… æ”¯æŒèŒƒå›´æŸ¥è¯¢
- âœ… æ”¯æŒæœ‰åºéå†
- âœ… åŠ¨æ€ç»´æŠ¤æœ‰åºæ•°æ®

**ç¼ºç‚¹**:
- âŒ æœ€åæƒ…å†µé€€åŒ–æˆé“¾è¡¨ O(n)
- âŒ éœ€è¦é¢å¤–çš„æŒ‡é’ˆç©ºé—´
- âŒ ä¸å¦‚å“ˆå¸Œè¡¨å¿«(æŸ¥æ‰¾)

### å¹³è¡¡äºŒå‰æœç´¢æ ‘

ä¸ºäº†é¿å… BST é€€åŒ–,å¼•å…¥äº†è‡ªå¹³è¡¡æ ‘:

#### 1. AVL æ ‘
```
ç‰¹ç‚¹:
- ä¸¥æ ¼å¹³è¡¡: |å·¦å­æ ‘é«˜åº¦ - å³å­æ ‘é«˜åº¦| â‰¤ 1
- é€šè¿‡æ—‹è½¬ä¿æŒå¹³è¡¡
- æŸ¥æ‰¾æ•ˆç‡é«˜,ä½†æ’å…¥åˆ é™¤éœ€è¦é¢‘ç¹æ—‹è½¬

æ—¶é—´å¤æ‚åº¦:
- æŸ¥æ‰¾: O(log n)
- æ’å…¥: O(log n)
- åˆ é™¤: O(log n)
```

#### 2. çº¢é»‘æ ‘
```
ç‰¹ç‚¹:
- è¿‘ä¼¼å¹³è¡¡: æœ€é•¿è·¯å¾„ â‰¤ 2 * æœ€çŸ­è·¯å¾„
- é€šè¿‡é¢œè‰²æ ‡è®°å’Œæ—‹è½¬ä¿æŒå¹³è¡¡
- æ’å…¥åˆ é™¤æ•ˆç‡é«˜

åº”ç”¨:
- C++ STL çš„ map/set
- Java çš„ TreeMap/TreeSet
- Linux å†…æ ¸çš„è¿›ç¨‹è°ƒåº¦
```

#### 3. Bæ ‘/B+æ ‘
```
ç‰¹ç‚¹:
- å¤šè·¯æœç´¢æ ‘(ä¸æ˜¯äºŒå‰æ ‘)
- èŠ‚ç‚¹å¯ä»¥æœ‰å¤šä¸ªå­èŠ‚ç‚¹
- å‡å°‘ç£ç›˜ I/O æ¬¡æ•°

åº”ç”¨:
- æ•°æ®åº“ç´¢å¼• (MySQL InnoDB)
- æ–‡ä»¶ç³»ç»Ÿ (NTFS, ext4)
```

### å¸¸è§é™·é˜±

1. **å¿˜è®°å¤„ç†ç›¸ç­‰çš„æƒ…å†µ**:
```typescript
// âŒ æ²¡æœ‰å¤„ç†ç›¸ç­‰
if (value < node.value) {
// æ’å…¥å·¦è¾¹
} else {
// æ’å…¥å³è¾¹,ç›¸ç­‰çš„ä¹Ÿä¼šæ’å…¥
}

// âœ… æ­£ç¡®å¤„ç†
if (value < node.value) {
// æ’å…¥å·¦è¾¹
} else if (value > node.value) {
// æ’å…¥å³è¾¹
} else {
// å€¼å·²å­˜åœ¨,ä¸æ’å…¥æˆ–æ›´æ–°
}
```

2. **åˆ é™¤èŠ‚ç‚¹æ—¶å¿˜è®°å¤„ç†ä¸¤ä¸ªå­èŠ‚ç‚¹çš„æƒ…å†µ**:
```typescript
// å¿…é¡»æ‰¾åˆ°åç»§èŠ‚ç‚¹(å³å­æ ‘çš„æœ€å°èŠ‚ç‚¹)
// æˆ–å‰é©±èŠ‚ç‚¹(å·¦å­æ ‘çš„æœ€å¤§èŠ‚ç‚¹)
```

3. **èŒƒå›´æŸ¥è¯¢æ—¶æ²¡æœ‰å‰ªæ**:
```typescript
// âŒ éå†æ‰€æœ‰èŠ‚ç‚¹
function rangeSearch(node, min, max) {
if (!node) return;
rangeSearch(node.left, min, max);
if (node.value >= min && node.value <= max) {
  result.push(node.value);
}
rangeSearch(node.right, min, max);
}

// âœ… å‰ªæä¼˜åŒ–
function rangeSearch(node, min, max) {
if (!node) return;
if (node.value > min) {
  rangeSearch(node.left, min, max); // åªæœ‰å¯èƒ½åœ¨å·¦è¾¹æ—¶æ‰æœç´¢
}
if (node.value >= min && node.value <= max) {
  result.push(node.value);
}
if (node.value < max) {
  rangeSearch(node.right, min, max); // åªæœ‰å¯èƒ½åœ¨å³è¾¹æ—¶æ‰æœç´¢
}
}
```

### æ€§èƒ½ä¼˜åŒ–å»ºè®®

- âœ… å¯¹äºé¢‘ç¹æ’å…¥åˆ é™¤,ä½¿ç”¨çº¢é»‘æ ‘ä»£æ›¿ BST
- âœ… å¯¹äºé™æ€æ•°æ®,å¯ä»¥ä»æœ‰åºæ•°ç»„æ„å»ºå¹³è¡¡ BST
- âœ… èŒƒå›´æŸ¥è¯¢æ—¶æ³¨æ„å‰ªæ
- âœ… è€ƒè™‘ä½¿ç”¨è¿­ä»£ä»£æ›¿é€’å½’(é¿å…æ ˆæº¢å‡º)
- âœ… ç¼“å­˜å¸¸ç”¨æŸ¥è¯¢ç»“æœ

### è¿›é˜¶å­¦ä¹ 

1. **AVL æ ‘**: ä¸‹ä¸€ç¯‡è¯¦ç»†è®²è§£
2. **çº¢é»‘æ ‘**: ç†è§£æ—‹è½¬å’Œé¢œè‰²è°ƒæ•´
3. **Bæ ‘/B+æ ‘**: æ•°æ®åº“ç´¢å¼•åŸç†
4. **Treap**: æ ‘å †,éšæœºåŒ– BST
5. **Splay Tree**: è‡ªè°ƒæ•´æ ‘

---

## ä¸‹æœŸé¢„å‘Š

ä¸‹ä¸€ç¯‡æˆ‘ä»¬å°†å­¦ä¹ **å †ä¸ä¼˜å…ˆé˜Ÿåˆ—**,æ¢è®¨:
- æœ€å°å †/æœ€å¤§å †çš„å®ç°
- ä¼˜å…ˆé˜Ÿåˆ—çš„åº”ç”¨
- Top K é—®é¢˜
- ä»»åŠ¡è°ƒåº¦ç³»ç»Ÿ
---

**ç›¸å…³èµ„æº**:
- [LeetCode BST é¢˜å•](https://leetcode.cn/tag/binary-search-tree/)
- [å¯è§†åŒ– BST](https://visualgo.net/en/bst)
- [æœ¬ç³»åˆ—ä»£ç ä»“åº“](https://github.com/yourname/frontend-algorithms)
